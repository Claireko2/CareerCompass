# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class Company(bases.BaseCompany):
    """Represents a Company record"""

    id: _str
    name: _str
    website: Optional[_str] = None
    createdAt: datetime.datetime
    jobs: Optional[List['models.JobPosting']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CompanyKeys']] = None,
        exclude: Optional[Iterable['types.CompanyKeys']] = None,
        required: Optional[Iterable['types.CompanyKeys']] = None,
        optional: Optional[Iterable['types.CompanyKeys']] = None,
        relations: Optional[Mapping['types.CompanyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CompanyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Company_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Company_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Company_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Company_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Company_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Company_relational_fields:
                        raise errors.UnknownRelationalFieldError('Company', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Company / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Company',
            }
        )
        _created_partial_types.add(name)


class Location(bases.BaseLocation):
    """Represents a Location record"""

    id: _str
    city: Optional[_str] = None
    region: Optional[_str] = None
    country: _str
    latitude: Optional[_float] = None
    longitude: Optional[_float] = None
    jobs: Optional[List['models.JobPosting']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LocationKeys']] = None,
        exclude: Optional[Iterable['types.LocationKeys']] = None,
        required: Optional[Iterable['types.LocationKeys']] = None,
        optional: Optional[Iterable['types.LocationKeys']] = None,
        relations: Optional[Mapping['types.LocationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LocationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Location_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Location_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Location_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Location_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Location_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Location_relational_fields:
                        raise errors.UnknownRelationalFieldError('Location', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Location / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Location',
            }
        )
        _created_partial_types.add(name)


class JobPosting(bases.BaseJobPosting):
    """Represents a JobPosting record"""

    id: _str
    jobId: _str
    title: _str
    description: _str
    qualifications: Optional['fields.Json'] = None
    responsibilities: Optional['fields.Json'] = None
    benefits: Optional['fields.Json'] = None
    postedAt: Optional[datetime.datetime] = None
    scrapedAt: datetime.datetime
    url: _str
    updatedAt: datetime.datetime
    company: Optional['models.Company'] = None
    companyId: _str
    location: Optional['models.Location'] = None
    locationId: _str
    skills: Optional[List['models.JobSkill']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.JobPostingKeys']] = None,
        exclude: Optional[Iterable['types.JobPostingKeys']] = None,
        required: Optional[Iterable['types.JobPostingKeys']] = None,
        optional: Optional[Iterable['types.JobPostingKeys']] = None,
        relations: Optional[Mapping['types.JobPostingRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.JobPostingKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _JobPosting_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _JobPosting_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _JobPosting_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _JobPosting_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _JobPosting_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _JobPosting_relational_fields:
                        raise errors.UnknownRelationalFieldError('JobPosting', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid JobPosting / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'JobPosting',
            }
        )
        _created_partial_types.add(name)


class Skill(bases.BaseSkill):
    """Represents a Skill record"""

    id: _str
    label: _str
    altLabels: Optional['fields.Json'] = None
    skill_type: Optional[_str] = None
    status: Optional[_str] = None
    modified_at: Optional[datetime.datetime] = None
    description: Optional[_str] = None
    skillsInJobs: Optional[List['models.JobSkill']] = None
    occupationSkills: Optional[List['models.OccupationSkill']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SkillKeys']] = None,
        exclude: Optional[Iterable['types.SkillKeys']] = None,
        required: Optional[Iterable['types.SkillKeys']] = None,
        optional: Optional[Iterable['types.SkillKeys']] = None,
        relations: Optional[Mapping['types.SkillRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SkillKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Skill_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Skill_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Skill_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Skill_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Skill_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Skill_relational_fields:
                        raise errors.UnknownRelationalFieldError('Skill', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Skill / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Skill',
            }
        )
        _created_partial_types.add(name)


class JobSkill(bases.BaseJobSkill):
    """Represents a JobSkill record"""

    jobId: _str
    skillId: _str
    job: Optional['models.JobPosting'] = None
    skill: Optional['models.Skill'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.JobSkillKeys']] = None,
        exclude: Optional[Iterable['types.JobSkillKeys']] = None,
        required: Optional[Iterable['types.JobSkillKeys']] = None,
        optional: Optional[Iterable['types.JobSkillKeys']] = None,
        relations: Optional[Mapping['types.JobSkillRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.JobSkillKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _JobSkill_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _JobSkill_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _JobSkill_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _JobSkill_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _JobSkill_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _JobSkill_relational_fields:
                        raise errors.UnknownRelationalFieldError('JobSkill', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid JobSkill / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'JobSkill',
            }
        )
        _created_partial_types.add(name)


class Occupation(bases.BaseOccupation):
    """Represents a Occupation record"""

    id: _str
    title: _str
    description: Optional[_str] = None
    source: _str
    skills: Optional[List['models.OccupationSkill']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OccupationKeys']] = None,
        exclude: Optional[Iterable['types.OccupationKeys']] = None,
        required: Optional[Iterable['types.OccupationKeys']] = None,
        optional: Optional[Iterable['types.OccupationKeys']] = None,
        relations: Optional[Mapping['types.OccupationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OccupationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Occupation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Occupation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Occupation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Occupation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Occupation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Occupation_relational_fields:
                        raise errors.UnknownRelationalFieldError('Occupation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Occupation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Occupation',
            }
        )
        _created_partial_types.add(name)


class OccupationSkill(bases.BaseOccupationSkill):
    """Represents a OccupationSkill record"""

    occupationId: _str
    skillId: _str
    relationType: Optional[_str] = None
    skillType: Optional[_str] = None
    occupation: Optional['models.Occupation'] = None
    skill: Optional['models.Skill'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OccupationSkillKeys']] = None,
        exclude: Optional[Iterable['types.OccupationSkillKeys']] = None,
        required: Optional[Iterable['types.OccupationSkillKeys']] = None,
        optional: Optional[Iterable['types.OccupationSkillKeys']] = None,
        relations: Optional[Mapping['types.OccupationSkillRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OccupationSkillKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _OccupationSkill_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _OccupationSkill_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _OccupationSkill_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _OccupationSkill_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _OccupationSkill_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _OccupationSkill_relational_fields:
                        raise errors.UnknownRelationalFieldError('OccupationSkill', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid OccupationSkill / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'OccupationSkill',
            }
        )
        _created_partial_types.add(name)


class Resume(bases.BaseResume):
    """Represents a Resume record"""

    id: _str
    name: Optional[_str] = None
    email: Optional[_str] = None
    phone: Optional[_str] = None
    rawText: _str
    createdAt: datetime.datetime
    skills: Optional[List['models.ResumeSkill']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ResumeKeys']] = None,
        exclude: Optional[Iterable['types.ResumeKeys']] = None,
        required: Optional[Iterable['types.ResumeKeys']] = None,
        optional: Optional[Iterable['types.ResumeKeys']] = None,
        relations: Optional[Mapping['types.ResumeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ResumeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Resume_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Resume_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Resume_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Resume_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Resume_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Resume_relational_fields:
                        raise errors.UnknownRelationalFieldError('Resume', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Resume / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Resume',
            }
        )
        _created_partial_types.add(name)


class ResumeSkill(bases.BaseResumeSkill):
    """Represents a ResumeSkill record"""

    id: _str
    resume: Optional['models.Resume'] = None
    resumeId: _str
    skillName: _str
    canonicalSkillId: Optional[_str] = None
    source: _str



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ResumeSkillKeys']] = None,
        exclude: Optional[Iterable['types.ResumeSkillKeys']] = None,
        required: Optional[Iterable['types.ResumeSkillKeys']] = None,
        optional: Optional[Iterable['types.ResumeSkillKeys']] = None,
        relations: Optional[Mapping['types.ResumeSkillRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ResumeSkillKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ResumeSkill_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ResumeSkill_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ResumeSkill_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ResumeSkill_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ResumeSkill_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ResumeSkill_relational_fields:
                        raise errors.UnknownRelationalFieldError('ResumeSkill', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ResumeSkill / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ResumeSkill',
            }
        )
        _created_partial_types.add(name)



_Company_relational_fields: Set[str] = {
        'jobs',
    }
_Company_fields: Dict['types.CompanyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('website', {
            'name': 'website',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobs', {
            'name': 'jobs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.JobPosting\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Location_relational_fields: Set[str] = {
        'jobs',
    }
_Location_fields: Dict['types.LocationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('city', {
            'name': 'city',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('region', {
            'name': 'region',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('country', {
            'name': 'country',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('latitude', {
            'name': 'latitude',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('longitude', {
            'name': 'longitude',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobs', {
            'name': 'jobs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.JobPosting\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_JobPosting_relational_fields: Set[str] = {
        'company',
        'location',
        'skills',
    }
_JobPosting_fields: Dict['types.JobPostingKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobId', {
            'name': 'jobId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('qualifications', {
            'name': 'qualifications',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('responsibilities', {
            'name': 'responsibilities',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('benefits', {
            'name': 'benefits',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('postedAt', {
            'name': 'postedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('scrapedAt', {
            'name': 'scrapedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': True,
            'type': 'models.Location',
            'is_relational': True,
            'documentation': None,
        }),
        ('locationId', {
            'name': 'locationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.JobSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Skill_relational_fields: Set[str] = {
        'skillsInJobs',
        'occupationSkills',
    }
_Skill_fields: Dict['types.SkillKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('label', {
            'name': 'label',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('altLabels', {
            'name': 'altLabels',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('skill_type', {
            'name': 'skill_type',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('modified_at', {
            'name': 'modified_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillsInJobs', {
            'name': 'skillsInJobs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.JobSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('occupationSkills', {
            'name': 'occupationSkills',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OccupationSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_JobSkill_relational_fields: Set[str] = {
        'job',
        'skill',
    }
_JobSkill_fields: Dict['types.JobSkillKeys', PartialModelField] = OrderedDict(
    [
        ('jobId', {
            'name': 'jobId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillId', {
            'name': 'skillId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.JobPosting',
            'is_relational': True,
            'documentation': None,
        }),
        ('skill', {
            'name': 'skill',
            'is_list': False,
            'optional': True,
            'type': 'models.Skill',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Occupation_relational_fields: Set[str] = {
        'skills',
    }
_Occupation_fields: Dict['types.OccupationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OccupationSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_OccupationSkill_relational_fields: Set[str] = {
        'occupation',
        'skill',
    }
_OccupationSkill_fields: Dict['types.OccupationSkillKeys', PartialModelField] = OrderedDict(
    [
        ('occupationId', {
            'name': 'occupationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillId', {
            'name': 'skillId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('relationType', {
            'name': 'relationType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillType', {
            'name': 'skillType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('occupation', {
            'name': 'occupation',
            'is_list': False,
            'optional': True,
            'type': 'models.Occupation',
            'is_relational': True,
            'documentation': None,
        }),
        ('skill', {
            'name': 'skill',
            'is_list': False,
            'optional': True,
            'type': 'models.Skill',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Resume_relational_fields: Set[str] = {
        'skills',
    }
_Resume_fields: Dict['types.ResumeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rawText', {
            'name': 'rawText',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ResumeSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ResumeSkill_relational_fields: Set[str] = {
        'resume',
    }
_ResumeSkill_fields: Dict['types.ResumeSkillKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('resume', {
            'name': 'resume',
            'is_list': False,
            'optional': True,
            'type': 'models.Resume',
            'is_relational': True,
            'documentation': None,
        }),
        ('resumeId', {
            'name': 'resumeId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillName', {
            'name': 'skillName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('canonicalSkillId', {
            'name': 'canonicalSkillId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(Company)
model_rebuild(Location)
model_rebuild(JobPosting)
model_rebuild(Skill)
model_rebuild(JobSkill)
model_rebuild(Occupation)
model_rebuild(OccupationSkill)
model_rebuild(Resume)
model_rebuild(ResumeSkill)
