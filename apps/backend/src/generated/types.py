# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Company types

class CompanyOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Company create method"""
    id: _str
    website: Optional[_str]
    createdAt: datetime.datetime
    jobs: 'JobPostingCreateManyNestedWithoutRelationsInput'


class CompanyCreateInput(CompanyOptionalCreateInput):
    """Required arguments to the Company create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CompanyOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Company create method, without relations"""
    id: _str
    website: Optional[_str]
    createdAt: datetime.datetime


class CompanyCreateWithoutRelationsInput(CompanyOptionalCreateWithoutRelationsInput):
    """Required arguments to the Company create method, without relations"""
    name: _str

class CompanyConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CompanyCreateWithoutRelationsInput'
    where: 'CompanyWhereUniqueInput'

class CompanyCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CompanyCreateWithoutRelationsInput'
    connect: 'CompanyWhereUniqueInput'
    connect_or_create: 'CompanyConnectOrCreateWithoutRelationsInput'


class CompanyCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CompanyCreateWithoutRelationsInput', List['CompanyCreateWithoutRelationsInput']]
    connect: Union['CompanyWhereUniqueInput', List['CompanyWhereUniqueInput']]
    connect_or_create: Union['CompanyConnectOrCreateWithoutRelationsInput', List['CompanyConnectOrCreateWithoutRelationsInput']]

_CompanyWhereUnique_id_Input = TypedDict(
    '_CompanyWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_CompanyWhereUnique_name_Input = TypedDict(
    '_CompanyWhereUnique_name_Input',
    {
        'name': '_str',
    },
    total=True
)

CompanyWhereUniqueInput = Union[
    '_CompanyWhereUnique_id_Input',
    '_CompanyWhereUnique_name_Input',
]


class CompanyUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    website: Optional[_str]
    createdAt: datetime.datetime
    jobs: 'JobPostingUpdateManyWithoutRelationsInput'


class CompanyUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    website: Optional[_str]
    createdAt: datetime.datetime


class CompanyUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CompanyCreateWithoutRelationsInput']
    connect: List['CompanyWhereUniqueInput']
    connect_or_create: List['CompanyConnectOrCreateWithoutRelationsInput']
    set: List['CompanyWhereUniqueInput']
    disconnect: List['CompanyWhereUniqueInput']
    delete: List['CompanyWhereUniqueInput']

    # TODO
    # update: List['CompanyUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CompanyUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CompanyScalarWhereInput']
    # upsert: List['CompanyUpserteWithWhereUniqueWithoutRelationsInput']


class CompanyUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CompanyCreateWithoutRelationsInput'
    connect: 'CompanyWhereUniqueInput'
    connect_or_create: 'CompanyConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CompanyUpdateInput'
    # upsert: 'CompanyUpsertWithoutRelationsInput'


class CompanyUpsertInput(TypedDict):
    create: 'CompanyCreateInput'
    update: 'CompanyUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Company_id_OrderByInput = TypedDict(
    '_Company_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Company_name_OrderByInput = TypedDict(
    '_Company_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Company_website_OrderByInput = TypedDict(
    '_Company_website_OrderByInput',
    {
        'website': 'SortOrder',
    },
    total=True
)

_Company_createdAt_OrderByInput = TypedDict(
    '_Company_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Company_RelevanceInner = TypedDict(
    '_Company_RelevanceInner',
    {
        'fields': 'List[CompanyScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Company_RelevanceOrderByInput = TypedDict(
    '_Company_RelevanceOrderByInput',
    {
        '_relevance': '_Company_RelevanceInner',
    },
    total=True
)

CompanyOrderByInput = Union[
    '_Company_id_OrderByInput',
    '_Company_name_OrderByInput',
    '_Company_website_OrderByInput',
    '_Company_createdAt_OrderByInput',
    '_Company_RelevanceOrderByInput',
]



# recursive Company types
# TODO: cleanup these types



CompanyRelationFilter = TypedDict(
    'CompanyRelationFilter',
    {
        'is': 'CompanyWhereInput',
        'is_not': 'CompanyWhereInput',
    },
    total=False,
)


class CompanyListRelationFilter(TypedDict, total=False):
    some: 'CompanyWhereInput'
    none: 'CompanyWhereInput'
    every: 'CompanyWhereInput'


class CompanyInclude(TypedDict, total=False):
    """Company relational arguments"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromCompany']


class CompanyIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromCompany']


class CompanyArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromCompany']


class LocationArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    company: Union[bool, 'CompanyArgsFromCompany']
    location: Union[bool, 'LocationArgsFromCompany']
    skills: Union[bool, 'FindManyJobSkillArgsFromCompany']


class JobPostingArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromCompany']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromCompany']


class SkillArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    job: Union[bool, 'JobPostingArgsFromCompany']
    skill: Union[bool, 'SkillArgsFromCompany']


class JobSkillArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromCompany']


class OccupationArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    occupation: Union[bool, 'OccupationArgsFromCompany']
    skill: Union[bool, 'SkillArgsFromCompany']


class OccupationSkillArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromCompany']


class ResumeArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromCompany(TypedDict, total=False):
    """Relational arguments for Company"""
    resume: Union[bool, 'ResumeArgsFromCompany']


class ResumeSkillArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromCompany(TypedDict, total=False):
    """Arguments for Company"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManyCompanyArgs = FindManyCompanyArgsFromCompany
FindFirstCompanyArgs = FindManyCompanyArgsFromCompany


class CompanyWhereInput(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    website: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    jobs: 'JobPostingListRelationFilter'

    # should be noted that AND and NOT should be Union['CompanyWhereInput', List['CompanyWhereInput']]
    # but this causes mypy to hang :/
    AND: List['CompanyWhereInput']
    OR: List['CompanyWhereInput']
    NOT: List['CompanyWhereInput']



# aggregate Company types


class CompanyScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Company arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    website: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CompanyScalarWhereWithAggregatesInput']
    OR: List['CompanyScalarWhereWithAggregatesInput']
    NOT: List['CompanyScalarWhereWithAggregatesInput']



class CompanyGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    website: _str
    createdAt: datetime.datetime
    _sum: 'CompanySumAggregateOutput'
    _avg: 'CompanyAvgAggregateOutput'
    _min: 'CompanyMinAggregateOutput'
    _max: 'CompanyMaxAggregateOutput'
    _count: 'CompanyCountAggregateOutput'


class CompanyAvgAggregateOutput(TypedDict, total=False):
    """Company output for aggregating averages"""


class CompanySumAggregateOutput(TypedDict, total=False):
    """Company output for aggregating sums"""


class CompanyScalarAggregateOutput(TypedDict, total=False):
    """Company output including scalar fields"""
    id: _str
    name: _str
    website: _str
    createdAt: datetime.datetime


CompanyMinAggregateOutput = CompanyScalarAggregateOutput
CompanyMaxAggregateOutput = CompanyScalarAggregateOutput


class CompanyMaxAggregateInput(TypedDict, total=False):
    """Company input for aggregating by max"""
    id: bool
    name: bool
    website: bool
    createdAt: bool


class CompanyMinAggregateInput(TypedDict, total=False):
    """Company input for aggregating by min"""
    id: bool
    name: bool
    website: bool
    createdAt: bool


class CompanyNumberAggregateInput(TypedDict, total=False):
    """Company input for aggregating numbers"""


CompanyAvgAggregateInput = CompanyNumberAggregateInput
CompanySumAggregateInput = CompanyNumberAggregateInput


CompanyCountAggregateInput = TypedDict(
    'CompanyCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'website': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

CompanyCountAggregateOutput = TypedDict(
    'CompanyCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'website': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


CompanyKeys = Literal[
    'id',
    'name',
    'website',
    'createdAt',
    'jobs',
]
CompanyScalarFieldKeys = Literal[
    'id',
    'name',
    'website',
    'createdAt',
]
CompanyScalarFieldKeysT = TypeVar('CompanyScalarFieldKeysT', bound=CompanyScalarFieldKeys)

CompanyRelationalFieldKeys = Literal[
        'jobs',
    ]

# Location types

class LocationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Location create method"""
    id: _str
    city: Optional[_str]
    region: Optional[_str]
    latitude: Optional[_float]
    longitude: Optional[_float]
    jobs: 'JobPostingCreateManyNestedWithoutRelationsInput'


class LocationCreateInput(LocationOptionalCreateInput):
    """Required arguments to the Location create method"""
    country: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class LocationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Location create method, without relations"""
    id: _str
    city: Optional[_str]
    region: Optional[_str]
    latitude: Optional[_float]
    longitude: Optional[_float]


class LocationCreateWithoutRelationsInput(LocationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Location create method, without relations"""
    country: _str

class LocationConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'LocationCreateWithoutRelationsInput'
    where: 'LocationWhereUniqueInput'

class LocationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'LocationCreateWithoutRelationsInput'
    connect: 'LocationWhereUniqueInput'
    connect_or_create: 'LocationConnectOrCreateWithoutRelationsInput'


class LocationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['LocationCreateWithoutRelationsInput', List['LocationCreateWithoutRelationsInput']]
    connect: Union['LocationWhereUniqueInput', List['LocationWhereUniqueInput']]
    connect_or_create: Union['LocationConnectOrCreateWithoutRelationsInput', List['LocationConnectOrCreateWithoutRelationsInput']]

_LocationWhereUnique_id_Input = TypedDict(
    '_LocationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_LocationCompoundcity_region_countryKeyInner = TypedDict(
    '_LocationCompoundcity_region_countryKeyInner',
    {
        'city': '_str',
        'region': '_str',
        'country': '_str',
    },
    total=True
)

_LocationCompoundcity_region_countryKey = TypedDict(
    '_LocationCompoundcity_region_countryKey',
    {
        'city_region_country': '_LocationCompoundcity_region_countryKeyInner',
    },
    total=True
)

LocationWhereUniqueInput = Union[
    '_LocationWhereUnique_id_Input',
    '_LocationCompoundcity_region_countryKey',
]


class LocationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    city: Optional[_str]
    region: Optional[_str]
    country: _str
    latitude: Optional[Union[AtomicFloatInput, _float]]
    longitude: Optional[Union[AtomicFloatInput, _float]]
    jobs: 'JobPostingUpdateManyWithoutRelationsInput'


class LocationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    city: Optional[_str]
    region: Optional[_str]
    country: _str
    latitude: Optional[Union[AtomicFloatInput, _float]]
    longitude: Optional[Union[AtomicFloatInput, _float]]


class LocationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['LocationCreateWithoutRelationsInput']
    connect: List['LocationWhereUniqueInput']
    connect_or_create: List['LocationConnectOrCreateWithoutRelationsInput']
    set: List['LocationWhereUniqueInput']
    disconnect: List['LocationWhereUniqueInput']
    delete: List['LocationWhereUniqueInput']

    # TODO
    # update: List['LocationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['LocationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['LocationScalarWhereInput']
    # upsert: List['LocationUpserteWithWhereUniqueWithoutRelationsInput']


class LocationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'LocationCreateWithoutRelationsInput'
    connect: 'LocationWhereUniqueInput'
    connect_or_create: 'LocationConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'LocationUpdateInput'
    # upsert: 'LocationUpsertWithoutRelationsInput'


class LocationUpsertInput(TypedDict):
    create: 'LocationCreateInput'
    update: 'LocationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Location_id_OrderByInput = TypedDict(
    '_Location_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Location_city_OrderByInput = TypedDict(
    '_Location_city_OrderByInput',
    {
        'city': 'SortOrder',
    },
    total=True
)

_Location_region_OrderByInput = TypedDict(
    '_Location_region_OrderByInput',
    {
        'region': 'SortOrder',
    },
    total=True
)

_Location_country_OrderByInput = TypedDict(
    '_Location_country_OrderByInput',
    {
        'country': 'SortOrder',
    },
    total=True
)

_Location_latitude_OrderByInput = TypedDict(
    '_Location_latitude_OrderByInput',
    {
        'latitude': 'SortOrder',
    },
    total=True
)

_Location_longitude_OrderByInput = TypedDict(
    '_Location_longitude_OrderByInput',
    {
        'longitude': 'SortOrder',
    },
    total=True
)

_Location_RelevanceInner = TypedDict(
    '_Location_RelevanceInner',
    {
        'fields': 'List[LocationScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Location_RelevanceOrderByInput = TypedDict(
    '_Location_RelevanceOrderByInput',
    {
        '_relevance': '_Location_RelevanceInner',
    },
    total=True
)

LocationOrderByInput = Union[
    '_Location_id_OrderByInput',
    '_Location_city_OrderByInput',
    '_Location_region_OrderByInput',
    '_Location_country_OrderByInput',
    '_Location_latitude_OrderByInput',
    '_Location_longitude_OrderByInput',
    '_Location_RelevanceOrderByInput',
]



# recursive Location types
# TODO: cleanup these types



LocationRelationFilter = TypedDict(
    'LocationRelationFilter',
    {
        'is': 'LocationWhereInput',
        'is_not': 'LocationWhereInput',
    },
    total=False,
)


class LocationListRelationFilter(TypedDict, total=False):
    some: 'LocationWhereInput'
    none: 'LocationWhereInput'
    every: 'LocationWhereInput'


class LocationInclude(TypedDict, total=False):
    """Location relational arguments"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromLocation']


class CompanyIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromLocation']


class CompanyArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromLocation']


class LocationArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    company: Union[bool, 'CompanyArgsFromLocation']
    location: Union[bool, 'LocationArgsFromLocation']
    skills: Union[bool, 'FindManyJobSkillArgsFromLocation']


class JobPostingArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromLocation']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromLocation']


class SkillArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    job: Union[bool, 'JobPostingArgsFromLocation']
    skill: Union[bool, 'SkillArgsFromLocation']


class JobSkillArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromLocation']


class OccupationArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    occupation: Union[bool, 'OccupationArgsFromLocation']
    skill: Union[bool, 'SkillArgsFromLocation']


class OccupationSkillArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromLocation']


class ResumeArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromLocation(TypedDict, total=False):
    """Relational arguments for Location"""
    resume: Union[bool, 'ResumeArgsFromLocation']


class ResumeSkillArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromLocation(TypedDict, total=False):
    """Arguments for Location"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManyLocationArgs = FindManyLocationArgsFromLocation
FindFirstLocationArgs = FindManyLocationArgsFromLocation


class LocationWhereInput(TypedDict, total=False):
    """Location arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    city: Union[None, _str, 'types.StringFilter']
    region: Union[None, _str, 'types.StringFilter']
    country: Union[_str, 'types.StringFilter']
    latitude: Union[None, _float, 'types.FloatFilter']
    longitude: Union[None, _float, 'types.FloatFilter']
    jobs: 'JobPostingListRelationFilter'

    # should be noted that AND and NOT should be Union['LocationWhereInput', List['LocationWhereInput']]
    # but this causes mypy to hang :/
    AND: List['LocationWhereInput']
    OR: List['LocationWhereInput']
    NOT: List['LocationWhereInput']



# aggregate Location types


class LocationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Location arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    city: Union[_str, 'types.StringWithAggregatesFilter']
    region: Union[_str, 'types.StringWithAggregatesFilter']
    country: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['LocationScalarWhereWithAggregatesInput']
    OR: List['LocationScalarWhereWithAggregatesInput']
    NOT: List['LocationScalarWhereWithAggregatesInput']



class LocationGroupByOutput(TypedDict, total=False):
    id: _str
    city: _str
    region: _str
    country: _str
    latitude: _float
    longitude: _float
    _sum: 'LocationSumAggregateOutput'
    _avg: 'LocationAvgAggregateOutput'
    _min: 'LocationMinAggregateOutput'
    _max: 'LocationMaxAggregateOutput'
    _count: 'LocationCountAggregateOutput'


class LocationAvgAggregateOutput(TypedDict, total=False):
    """Location output for aggregating averages"""
    latitude: float
    longitude: float


class LocationSumAggregateOutput(TypedDict, total=False):
    """Location output for aggregating sums"""
    latitude: _float
    longitude: _float


class LocationScalarAggregateOutput(TypedDict, total=False):
    """Location output including scalar fields"""
    id: _str
    city: _str
    region: _str
    country: _str
    latitude: _float
    longitude: _float


LocationMinAggregateOutput = LocationScalarAggregateOutput
LocationMaxAggregateOutput = LocationScalarAggregateOutput


class LocationMaxAggregateInput(TypedDict, total=False):
    """Location input for aggregating by max"""
    id: bool
    city: bool
    region: bool
    country: bool
    latitude: bool
    longitude: bool


class LocationMinAggregateInput(TypedDict, total=False):
    """Location input for aggregating by min"""
    id: bool
    city: bool
    region: bool
    country: bool
    latitude: bool
    longitude: bool


class LocationNumberAggregateInput(TypedDict, total=False):
    """Location input for aggregating numbers"""
    latitude: bool
    longitude: bool


LocationAvgAggregateInput = LocationNumberAggregateInput
LocationSumAggregateInput = LocationNumberAggregateInput


LocationCountAggregateInput = TypedDict(
    'LocationCountAggregateInput',
    {
        'id': bool,
        'city': bool,
        'region': bool,
        'country': bool,
        'latitude': bool,
        'longitude': bool,
        '_all': bool,
    },
    total=False,
)

LocationCountAggregateOutput = TypedDict(
    'LocationCountAggregateOutput',
    {
        'id': int,
        'city': int,
        'region': int,
        'country': int,
        'latitude': int,
        'longitude': int,
        '_all': int,
    },
    total=False,
)


LocationKeys = Literal[
    'id',
    'city',
    'region',
    'country',
    'latitude',
    'longitude',
    'jobs',
]
LocationScalarFieldKeys = Literal[
    'id',
    'city',
    'region',
    'country',
    'latitude',
    'longitude',
]
LocationScalarFieldKeysT = TypeVar('LocationScalarFieldKeysT', bound=LocationScalarFieldKeys)

LocationRelationalFieldKeys = Literal[
        'jobs',
    ]

# JobPosting types

class JobPostingOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the JobPosting create method"""
    id: _str
    qualifications: Optional['fields.Json']
    responsibilities: Optional['fields.Json']
    benefits: Optional['fields.Json']
    postedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    updatedAt: datetime.datetime
    company: 'CompanyCreateNestedWithoutRelationsInput'
    companyId: _str
    location: 'LocationCreateNestedWithoutRelationsInput'
    locationId: _str
    skills: 'JobSkillCreateManyNestedWithoutRelationsInput'


class JobPostingCreateInput(JobPostingOptionalCreateInput):
    """Required arguments to the JobPosting create method"""
    jobId: _str
    title: _str
    description: _str
    url: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class JobPostingOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the JobPosting create method, without relations"""
    id: _str
    qualifications: Optional['fields.Json']
    responsibilities: Optional['fields.Json']
    benefits: Optional['fields.Json']
    postedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    updatedAt: datetime.datetime
    companyId: _str
    locationId: _str


class JobPostingCreateWithoutRelationsInput(JobPostingOptionalCreateWithoutRelationsInput):
    """Required arguments to the JobPosting create method, without relations"""
    jobId: _str
    title: _str
    description: _str
    url: _str

class JobPostingConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'JobPostingCreateWithoutRelationsInput'
    where: 'JobPostingWhereUniqueInput'

class JobPostingCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'JobPostingCreateWithoutRelationsInput'
    connect: 'JobPostingWhereUniqueInput'
    connect_or_create: 'JobPostingConnectOrCreateWithoutRelationsInput'


class JobPostingCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['JobPostingCreateWithoutRelationsInput', List['JobPostingCreateWithoutRelationsInput']]
    connect: Union['JobPostingWhereUniqueInput', List['JobPostingWhereUniqueInput']]
    connect_or_create: Union['JobPostingConnectOrCreateWithoutRelationsInput', List['JobPostingConnectOrCreateWithoutRelationsInput']]

_JobPostingWhereUnique_id_Input = TypedDict(
    '_JobPostingWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_JobPostingWhereUnique_jobId_Input = TypedDict(
    '_JobPostingWhereUnique_jobId_Input',
    {
        'jobId': '_str',
    },
    total=True
)

JobPostingWhereUniqueInput = Union[
    '_JobPostingWhereUnique_id_Input',
    '_JobPostingWhereUnique_jobId_Input',
]


class JobPostingUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    jobId: _str
    title: _str
    description: _str
    qualifications: Optional['fields.Json']
    responsibilities: Optional['fields.Json']
    benefits: Optional['fields.Json']
    postedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    url: _str
    updatedAt: datetime.datetime
    company: 'CompanyUpdateOneWithoutRelationsInput'
    location: 'LocationUpdateOneWithoutRelationsInput'
    skills: 'JobSkillUpdateManyWithoutRelationsInput'


class JobPostingUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    jobId: _str
    title: _str
    description: _str
    qualifications: Optional['fields.Json']
    responsibilities: Optional['fields.Json']
    benefits: Optional['fields.Json']
    postedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    url: _str
    updatedAt: datetime.datetime


class JobPostingUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['JobPostingCreateWithoutRelationsInput']
    connect: List['JobPostingWhereUniqueInput']
    connect_or_create: List['JobPostingConnectOrCreateWithoutRelationsInput']
    set: List['JobPostingWhereUniqueInput']
    disconnect: List['JobPostingWhereUniqueInput']
    delete: List['JobPostingWhereUniqueInput']

    # TODO
    # update: List['JobPostingUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['JobPostingUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['JobPostingScalarWhereInput']
    # upsert: List['JobPostingUpserteWithWhereUniqueWithoutRelationsInput']


class JobPostingUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'JobPostingCreateWithoutRelationsInput'
    connect: 'JobPostingWhereUniqueInput'
    connect_or_create: 'JobPostingConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'JobPostingUpdateInput'
    # upsert: 'JobPostingUpsertWithoutRelationsInput'


class JobPostingUpsertInput(TypedDict):
    create: 'JobPostingCreateInput'
    update: 'JobPostingUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_JobPosting_id_OrderByInput = TypedDict(
    '_JobPosting_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_JobPosting_jobId_OrderByInput = TypedDict(
    '_JobPosting_jobId_OrderByInput',
    {
        'jobId': 'SortOrder',
    },
    total=True
)

_JobPosting_title_OrderByInput = TypedDict(
    '_JobPosting_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_JobPosting_description_OrderByInput = TypedDict(
    '_JobPosting_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_JobPosting_qualifications_OrderByInput = TypedDict(
    '_JobPosting_qualifications_OrderByInput',
    {
        'qualifications': 'SortOrder',
    },
    total=True
)

_JobPosting_responsibilities_OrderByInput = TypedDict(
    '_JobPosting_responsibilities_OrderByInput',
    {
        'responsibilities': 'SortOrder',
    },
    total=True
)

_JobPosting_benefits_OrderByInput = TypedDict(
    '_JobPosting_benefits_OrderByInput',
    {
        'benefits': 'SortOrder',
    },
    total=True
)

_JobPosting_postedAt_OrderByInput = TypedDict(
    '_JobPosting_postedAt_OrderByInput',
    {
        'postedAt': 'SortOrder',
    },
    total=True
)

_JobPosting_scrapedAt_OrderByInput = TypedDict(
    '_JobPosting_scrapedAt_OrderByInput',
    {
        'scrapedAt': 'SortOrder',
    },
    total=True
)

_JobPosting_url_OrderByInput = TypedDict(
    '_JobPosting_url_OrderByInput',
    {
        'url': 'SortOrder',
    },
    total=True
)

_JobPosting_updatedAt_OrderByInput = TypedDict(
    '_JobPosting_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_JobPosting_companyId_OrderByInput = TypedDict(
    '_JobPosting_companyId_OrderByInput',
    {
        'companyId': 'SortOrder',
    },
    total=True
)

_JobPosting_locationId_OrderByInput = TypedDict(
    '_JobPosting_locationId_OrderByInput',
    {
        'locationId': 'SortOrder',
    },
    total=True
)

_JobPosting_RelevanceInner = TypedDict(
    '_JobPosting_RelevanceInner',
    {
        'fields': 'List[JobPostingScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_JobPosting_RelevanceOrderByInput = TypedDict(
    '_JobPosting_RelevanceOrderByInput',
    {
        '_relevance': '_JobPosting_RelevanceInner',
    },
    total=True
)

JobPostingOrderByInput = Union[
    '_JobPosting_id_OrderByInput',
    '_JobPosting_jobId_OrderByInput',
    '_JobPosting_title_OrderByInput',
    '_JobPosting_description_OrderByInput',
    '_JobPosting_qualifications_OrderByInput',
    '_JobPosting_responsibilities_OrderByInput',
    '_JobPosting_benefits_OrderByInput',
    '_JobPosting_postedAt_OrderByInput',
    '_JobPosting_scrapedAt_OrderByInput',
    '_JobPosting_url_OrderByInput',
    '_JobPosting_updatedAt_OrderByInput',
    '_JobPosting_companyId_OrderByInput',
    '_JobPosting_locationId_OrderByInput',
    '_JobPosting_RelevanceOrderByInput',
]



# recursive JobPosting types
# TODO: cleanup these types



JobPostingRelationFilter = TypedDict(
    'JobPostingRelationFilter',
    {
        'is': 'JobPostingWhereInput',
        'is_not': 'JobPostingWhereInput',
    },
    total=False,
)


class JobPostingListRelationFilter(TypedDict, total=False):
    some: 'JobPostingWhereInput'
    none: 'JobPostingWhereInput'
    every: 'JobPostingWhereInput'


class JobPostingInclude(TypedDict, total=False):
    """JobPosting relational arguments"""
    company: Union[bool, 'CompanyArgsFromJobPosting']
    location: Union[bool, 'LocationArgsFromJobPosting']
    skills: Union[bool, 'FindManyJobSkillArgsFromJobPosting']


class CompanyIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromJobPosting']


class CompanyArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromJobPosting']


class LocationArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    company: Union[bool, 'CompanyArgsFromJobPosting']
    location: Union[bool, 'LocationArgsFromJobPosting']
    skills: Union[bool, 'FindManyJobSkillArgsFromJobPosting']


class JobPostingArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromJobPosting']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromJobPosting']


class SkillArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    job: Union[bool, 'JobPostingArgsFromJobPosting']
    skill: Union[bool, 'SkillArgsFromJobPosting']


class JobSkillArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromJobPosting']


class OccupationArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    occupation: Union[bool, 'OccupationArgsFromJobPosting']
    skill: Union[bool, 'SkillArgsFromJobPosting']


class OccupationSkillArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromJobPosting']


class ResumeArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromJobPosting(TypedDict, total=False):
    """Relational arguments for JobPosting"""
    resume: Union[bool, 'ResumeArgsFromJobPosting']


class ResumeSkillArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromJobPosting(TypedDict, total=False):
    """Arguments for JobPosting"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManyJobPostingArgs = FindManyJobPostingArgsFromJobPosting
FindFirstJobPostingArgs = FindManyJobPostingArgsFromJobPosting


class JobPostingWhereInput(TypedDict, total=False):
    """JobPosting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    jobId: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[_str, 'types.StringFilter']
    qualifications: Union[None, 'fields.Json', 'types.JsonFilter']
    responsibilities: Union[None, 'fields.Json', 'types.JsonFilter']
    benefits: Union[None, 'fields.Json', 'types.JsonFilter']
    postedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    url: Union[_str, 'types.StringFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    company: 'CompanyRelationFilter'
    companyId: Union[_str, 'types.StringFilter']
    location: 'LocationRelationFilter'
    locationId: Union[_str, 'types.StringFilter']
    skills: 'JobSkillListRelationFilter'

    # should be noted that AND and NOT should be Union['JobPostingWhereInput', List['JobPostingWhereInput']]
    # but this causes mypy to hang :/
    AND: List['JobPostingWhereInput']
    OR: List['JobPostingWhereInput']
    NOT: List['JobPostingWhereInput']



# aggregate JobPosting types


class JobPostingScalarWhereWithAggregatesInput(TypedDict, total=False):
    """JobPosting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    jobId: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    qualifications: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    responsibilities: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    benefits: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    postedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    url: Union[_str, 'types.StringWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    companyId: Union[_str, 'types.StringWithAggregatesFilter']
    locationId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['JobPostingScalarWhereWithAggregatesInput']
    OR: List['JobPostingScalarWhereWithAggregatesInput']
    NOT: List['JobPostingScalarWhereWithAggregatesInput']



class JobPostingGroupByOutput(TypedDict, total=False):
    id: _str
    jobId: _str
    title: _str
    description: _str
    qualifications: 'fields.Json'
    responsibilities: 'fields.Json'
    benefits: 'fields.Json'
    postedAt: datetime.datetime
    scrapedAt: datetime.datetime
    url: _str
    updatedAt: datetime.datetime
    companyId: _str
    locationId: _str
    _sum: 'JobPostingSumAggregateOutput'
    _avg: 'JobPostingAvgAggregateOutput'
    _min: 'JobPostingMinAggregateOutput'
    _max: 'JobPostingMaxAggregateOutput'
    _count: 'JobPostingCountAggregateOutput'


class JobPostingAvgAggregateOutput(TypedDict, total=False):
    """JobPosting output for aggregating averages"""


class JobPostingSumAggregateOutput(TypedDict, total=False):
    """JobPosting output for aggregating sums"""


class JobPostingScalarAggregateOutput(TypedDict, total=False):
    """JobPosting output including scalar fields"""
    id: _str
    jobId: _str
    title: _str
    description: _str
    qualifications: 'fields.Json'
    responsibilities: 'fields.Json'
    benefits: 'fields.Json'
    postedAt: datetime.datetime
    scrapedAt: datetime.datetime
    url: _str
    updatedAt: datetime.datetime
    companyId: _str
    locationId: _str


JobPostingMinAggregateOutput = JobPostingScalarAggregateOutput
JobPostingMaxAggregateOutput = JobPostingScalarAggregateOutput


class JobPostingMaxAggregateInput(TypedDict, total=False):
    """JobPosting input for aggregating by max"""
    id: bool
    jobId: bool
    title: bool
    description: bool
    qualifications: bool
    responsibilities: bool
    benefits: bool
    postedAt: bool
    scrapedAt: bool
    url: bool
    updatedAt: bool
    companyId: bool
    locationId: bool


class JobPostingMinAggregateInput(TypedDict, total=False):
    """JobPosting input for aggregating by min"""
    id: bool
    jobId: bool
    title: bool
    description: bool
    qualifications: bool
    responsibilities: bool
    benefits: bool
    postedAt: bool
    scrapedAt: bool
    url: bool
    updatedAt: bool
    companyId: bool
    locationId: bool


class JobPostingNumberAggregateInput(TypedDict, total=False):
    """JobPosting input for aggregating numbers"""


JobPostingAvgAggregateInput = JobPostingNumberAggregateInput
JobPostingSumAggregateInput = JobPostingNumberAggregateInput


JobPostingCountAggregateInput = TypedDict(
    'JobPostingCountAggregateInput',
    {
        'id': bool,
        'jobId': bool,
        'title': bool,
        'description': bool,
        'qualifications': bool,
        'responsibilities': bool,
        'benefits': bool,
        'postedAt': bool,
        'scrapedAt': bool,
        'url': bool,
        'updatedAt': bool,
        'companyId': bool,
        'locationId': bool,
        '_all': bool,
    },
    total=False,
)

JobPostingCountAggregateOutput = TypedDict(
    'JobPostingCountAggregateOutput',
    {
        'id': int,
        'jobId': int,
        'title': int,
        'description': int,
        'qualifications': int,
        'responsibilities': int,
        'benefits': int,
        'postedAt': int,
        'scrapedAt': int,
        'url': int,
        'updatedAt': int,
        'companyId': int,
        'locationId': int,
        '_all': int,
    },
    total=False,
)


JobPostingKeys = Literal[
    'id',
    'jobId',
    'title',
    'description',
    'qualifications',
    'responsibilities',
    'benefits',
    'postedAt',
    'scrapedAt',
    'url',
    'updatedAt',
    'company',
    'companyId',
    'location',
    'locationId',
    'skills',
]
JobPostingScalarFieldKeys = Literal[
    'id',
    'jobId',
    'title',
    'description',
    'qualifications',
    'responsibilities',
    'benefits',
    'postedAt',
    'scrapedAt',
    'url',
    'updatedAt',
    'companyId',
    'locationId',
]
JobPostingScalarFieldKeysT = TypeVar('JobPostingScalarFieldKeysT', bound=JobPostingScalarFieldKeys)

JobPostingRelationalFieldKeys = Literal[
        'company',
        'location',
        'skills',
    ]

# Skill types

class SkillOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Skill create method"""
    id: _str
    altLabels: Optional['fields.Json']
    skill_type: Optional[_str]
    status: Optional[_str]
    modified_at: Optional[datetime.datetime]
    description: Optional[_str]
    skillsInJobs: 'JobSkillCreateManyNestedWithoutRelationsInput'
    occupationSkills: 'OccupationSkillCreateManyNestedWithoutRelationsInput'


class SkillCreateInput(SkillOptionalCreateInput):
    """Required arguments to the Skill create method"""
    label: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SkillOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Skill create method, without relations"""
    id: _str
    altLabels: Optional['fields.Json']
    skill_type: Optional[_str]
    status: Optional[_str]
    modified_at: Optional[datetime.datetime]
    description: Optional[_str]


class SkillCreateWithoutRelationsInput(SkillOptionalCreateWithoutRelationsInput):
    """Required arguments to the Skill create method, without relations"""
    label: _str

class SkillConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'SkillCreateWithoutRelationsInput'
    where: 'SkillWhereUniqueInput'

class SkillCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SkillCreateWithoutRelationsInput'
    connect: 'SkillWhereUniqueInput'
    connect_or_create: 'SkillConnectOrCreateWithoutRelationsInput'


class SkillCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SkillCreateWithoutRelationsInput', List['SkillCreateWithoutRelationsInput']]
    connect: Union['SkillWhereUniqueInput', List['SkillWhereUniqueInput']]
    connect_or_create: Union['SkillConnectOrCreateWithoutRelationsInput', List['SkillConnectOrCreateWithoutRelationsInput']]

_SkillWhereUnique_id_Input = TypedDict(
    '_SkillWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

SkillWhereUniqueInput = _SkillWhereUnique_id_Input


class SkillUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    label: _str
    altLabels: Optional['fields.Json']
    skill_type: Optional[_str]
    status: Optional[_str]
    modified_at: Optional[datetime.datetime]
    description: Optional[_str]
    skillsInJobs: 'JobSkillUpdateManyWithoutRelationsInput'
    occupationSkills: 'OccupationSkillUpdateManyWithoutRelationsInput'


class SkillUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    label: _str
    altLabels: Optional['fields.Json']
    skill_type: Optional[_str]
    status: Optional[_str]
    modified_at: Optional[datetime.datetime]
    description: Optional[_str]


class SkillUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SkillCreateWithoutRelationsInput']
    connect: List['SkillWhereUniqueInput']
    connect_or_create: List['SkillConnectOrCreateWithoutRelationsInput']
    set: List['SkillWhereUniqueInput']
    disconnect: List['SkillWhereUniqueInput']
    delete: List['SkillWhereUniqueInput']

    # TODO
    # update: List['SkillUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SkillUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SkillScalarWhereInput']
    # upsert: List['SkillUpserteWithWhereUniqueWithoutRelationsInput']


class SkillUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SkillCreateWithoutRelationsInput'
    connect: 'SkillWhereUniqueInput'
    connect_or_create: 'SkillConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SkillUpdateInput'
    # upsert: 'SkillUpsertWithoutRelationsInput'


class SkillUpsertInput(TypedDict):
    create: 'SkillCreateInput'
    update: 'SkillUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Skill_id_OrderByInput = TypedDict(
    '_Skill_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Skill_label_OrderByInput = TypedDict(
    '_Skill_label_OrderByInput',
    {
        'label': 'SortOrder',
    },
    total=True
)

_Skill_altLabels_OrderByInput = TypedDict(
    '_Skill_altLabels_OrderByInput',
    {
        'altLabels': 'SortOrder',
    },
    total=True
)

_Skill_skill_type_OrderByInput = TypedDict(
    '_Skill_skill_type_OrderByInput',
    {
        'skill_type': 'SortOrder',
    },
    total=True
)

_Skill_status_OrderByInput = TypedDict(
    '_Skill_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Skill_modified_at_OrderByInput = TypedDict(
    '_Skill_modified_at_OrderByInput',
    {
        'modified_at': 'SortOrder',
    },
    total=True
)

_Skill_description_OrderByInput = TypedDict(
    '_Skill_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Skill_RelevanceInner = TypedDict(
    '_Skill_RelevanceInner',
    {
        'fields': 'List[SkillScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Skill_RelevanceOrderByInput = TypedDict(
    '_Skill_RelevanceOrderByInput',
    {
        '_relevance': '_Skill_RelevanceInner',
    },
    total=True
)

SkillOrderByInput = Union[
    '_Skill_id_OrderByInput',
    '_Skill_label_OrderByInput',
    '_Skill_altLabels_OrderByInput',
    '_Skill_skill_type_OrderByInput',
    '_Skill_status_OrderByInput',
    '_Skill_modified_at_OrderByInput',
    '_Skill_description_OrderByInput',
    '_Skill_RelevanceOrderByInput',
]



# recursive Skill types
# TODO: cleanup these types



SkillRelationFilter = TypedDict(
    'SkillRelationFilter',
    {
        'is': 'SkillWhereInput',
        'is_not': 'SkillWhereInput',
    },
    total=False,
)


class SkillListRelationFilter(TypedDict, total=False):
    some: 'SkillWhereInput'
    none: 'SkillWhereInput'
    every: 'SkillWhereInput'


class SkillInclude(TypedDict, total=False):
    """Skill relational arguments"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromSkill']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromSkill']


class CompanyIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromSkill']


class CompanyArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromSkill']


class LocationArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    company: Union[bool, 'CompanyArgsFromSkill']
    location: Union[bool, 'LocationArgsFromSkill']
    skills: Union[bool, 'FindManyJobSkillArgsFromSkill']


class JobPostingArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromSkill']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromSkill']


class SkillArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    job: Union[bool, 'JobPostingArgsFromSkill']
    skill: Union[bool, 'SkillArgsFromSkill']


class JobSkillArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromSkill']


class OccupationArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    occupation: Union[bool, 'OccupationArgsFromSkill']
    skill: Union[bool, 'SkillArgsFromSkill']


class OccupationSkillArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromSkill']


class ResumeArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromSkill(TypedDict, total=False):
    """Relational arguments for Skill"""
    resume: Union[bool, 'ResumeArgsFromSkill']


class ResumeSkillArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromSkill(TypedDict, total=False):
    """Arguments for Skill"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManySkillArgs = FindManySkillArgsFromSkill
FindFirstSkillArgs = FindManySkillArgsFromSkill


class SkillWhereInput(TypedDict, total=False):
    """Skill arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    label: Union[_str, 'types.StringFilter']
    altLabels: Union[None, 'fields.Json', 'types.JsonFilter']
    skill_type: Union[None, _str, 'types.StringFilter']
    status: Union[None, _str, 'types.StringFilter']
    modified_at: Union[None, datetime.datetime, 'types.DateTimeFilter']
    description: Union[None, _str, 'types.StringFilter']
    skillsInJobs: 'JobSkillListRelationFilter'
    occupationSkills: 'OccupationSkillListRelationFilter'

    # should be noted that AND and NOT should be Union['SkillWhereInput', List['SkillWhereInput']]
    # but this causes mypy to hang :/
    AND: List['SkillWhereInput']
    OR: List['SkillWhereInput']
    NOT: List['SkillWhereInput']



# aggregate Skill types


class SkillScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Skill arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    label: Union[_str, 'types.StringWithAggregatesFilter']
    altLabels: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    skill_type: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    modified_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SkillScalarWhereWithAggregatesInput']
    OR: List['SkillScalarWhereWithAggregatesInput']
    NOT: List['SkillScalarWhereWithAggregatesInput']



class SkillGroupByOutput(TypedDict, total=False):
    id: _str
    label: _str
    altLabels: 'fields.Json'
    skill_type: _str
    status: _str
    modified_at: datetime.datetime
    description: _str
    _sum: 'SkillSumAggregateOutput'
    _avg: 'SkillAvgAggregateOutput'
    _min: 'SkillMinAggregateOutput'
    _max: 'SkillMaxAggregateOutput'
    _count: 'SkillCountAggregateOutput'


class SkillAvgAggregateOutput(TypedDict, total=False):
    """Skill output for aggregating averages"""


class SkillSumAggregateOutput(TypedDict, total=False):
    """Skill output for aggregating sums"""


class SkillScalarAggregateOutput(TypedDict, total=False):
    """Skill output including scalar fields"""
    id: _str
    label: _str
    altLabels: 'fields.Json'
    skill_type: _str
    status: _str
    modified_at: datetime.datetime
    description: _str


SkillMinAggregateOutput = SkillScalarAggregateOutput
SkillMaxAggregateOutput = SkillScalarAggregateOutput


class SkillMaxAggregateInput(TypedDict, total=False):
    """Skill input for aggregating by max"""
    id: bool
    label: bool
    altLabels: bool
    skill_type: bool
    status: bool
    modified_at: bool
    description: bool


class SkillMinAggregateInput(TypedDict, total=False):
    """Skill input for aggregating by min"""
    id: bool
    label: bool
    altLabels: bool
    skill_type: bool
    status: bool
    modified_at: bool
    description: bool


class SkillNumberAggregateInput(TypedDict, total=False):
    """Skill input for aggregating numbers"""


SkillAvgAggregateInput = SkillNumberAggregateInput
SkillSumAggregateInput = SkillNumberAggregateInput


SkillCountAggregateInput = TypedDict(
    'SkillCountAggregateInput',
    {
        'id': bool,
        'label': bool,
        'altLabels': bool,
        'skill_type': bool,
        'status': bool,
        'modified_at': bool,
        'description': bool,
        '_all': bool,
    },
    total=False,
)

SkillCountAggregateOutput = TypedDict(
    'SkillCountAggregateOutput',
    {
        'id': int,
        'label': int,
        'altLabels': int,
        'skill_type': int,
        'status': int,
        'modified_at': int,
        'description': int,
        '_all': int,
    },
    total=False,
)


SkillKeys = Literal[
    'id',
    'label',
    'altLabels',
    'skill_type',
    'status',
    'modified_at',
    'description',
    'skillsInJobs',
    'occupationSkills',
]
SkillScalarFieldKeys = Literal[
    'id',
    'label',
    'altLabels',
    'skill_type',
    'status',
    'modified_at',
    'description',
]
SkillScalarFieldKeysT = TypeVar('SkillScalarFieldKeysT', bound=SkillScalarFieldKeys)

SkillRelationalFieldKeys = Literal[
        'skillsInJobs',
        'occupationSkills',
    ]

# JobSkill types

class JobSkillOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the JobSkill create method"""
    jobId: _str
    skillId: _str
    job: 'JobPostingCreateNestedWithoutRelationsInput'
    skill: 'SkillCreateNestedWithoutRelationsInput'


class JobSkillCreateInput(JobSkillOptionalCreateInput):
    """Required arguments to the JobSkill create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class JobSkillOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the JobSkill create method, without relations"""
    jobId: _str
    skillId: _str


class JobSkillCreateWithoutRelationsInput(JobSkillOptionalCreateWithoutRelationsInput):
    """Required arguments to the JobSkill create method, without relations"""

class JobSkillConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'JobSkillCreateWithoutRelationsInput'
    where: 'JobSkillWhereUniqueInput'

class JobSkillCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'JobSkillCreateWithoutRelationsInput'
    connect: 'JobSkillWhereUniqueInput'
    connect_or_create: 'JobSkillConnectOrCreateWithoutRelationsInput'


class JobSkillCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['JobSkillCreateWithoutRelationsInput', List['JobSkillCreateWithoutRelationsInput']]
    connect: Union['JobSkillWhereUniqueInput', List['JobSkillWhereUniqueInput']]
    connect_or_create: Union['JobSkillConnectOrCreateWithoutRelationsInput', List['JobSkillConnectOrCreateWithoutRelationsInput']]

_JobSkillCompoundPrimaryKeyInner = TypedDict(
    '_JobSkillCompoundPrimaryKeyInner',
    {
        'jobId': '_str',
        'skillId': '_str',
    },
    total=True
)

_JobSkillCompoundPrimaryKey = TypedDict(
    '_JobSkillCompoundPrimaryKey',
    {
        'jobId_skillId': '_JobSkillCompoundPrimaryKeyInner',
    },
    total=True
)

JobSkillWhereUniqueInput = _JobSkillCompoundPrimaryKey


class JobSkillUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    job: 'JobPostingUpdateOneWithoutRelationsInput'
    skill: 'SkillUpdateOneWithoutRelationsInput'


class JobSkillUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""


class JobSkillUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['JobSkillCreateWithoutRelationsInput']
    connect: List['JobSkillWhereUniqueInput']
    connect_or_create: List['JobSkillConnectOrCreateWithoutRelationsInput']
    set: List['JobSkillWhereUniqueInput']
    disconnect: List['JobSkillWhereUniqueInput']
    delete: List['JobSkillWhereUniqueInput']

    # TODO
    # update: List['JobSkillUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['JobSkillUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['JobSkillScalarWhereInput']
    # upsert: List['JobSkillUpserteWithWhereUniqueWithoutRelationsInput']


class JobSkillUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'JobSkillCreateWithoutRelationsInput'
    connect: 'JobSkillWhereUniqueInput'
    connect_or_create: 'JobSkillConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'JobSkillUpdateInput'
    # upsert: 'JobSkillUpsertWithoutRelationsInput'


class JobSkillUpsertInput(TypedDict):
    create: 'JobSkillCreateInput'
    update: 'JobSkillUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_JobSkill_jobId_OrderByInput = TypedDict(
    '_JobSkill_jobId_OrderByInput',
    {
        'jobId': 'SortOrder',
    },
    total=True
)

_JobSkill_skillId_OrderByInput = TypedDict(
    '_JobSkill_skillId_OrderByInput',
    {
        'skillId': 'SortOrder',
    },
    total=True
)

_JobSkill_RelevanceInner = TypedDict(
    '_JobSkill_RelevanceInner',
    {
        'fields': 'List[JobSkillScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_JobSkill_RelevanceOrderByInput = TypedDict(
    '_JobSkill_RelevanceOrderByInput',
    {
        '_relevance': '_JobSkill_RelevanceInner',
    },
    total=True
)

JobSkillOrderByInput = Union[
    '_JobSkill_jobId_OrderByInput',
    '_JobSkill_skillId_OrderByInput',
    '_JobSkill_RelevanceOrderByInput',
]



# recursive JobSkill types
# TODO: cleanup these types



JobSkillRelationFilter = TypedDict(
    'JobSkillRelationFilter',
    {
        'is': 'JobSkillWhereInput',
        'is_not': 'JobSkillWhereInput',
    },
    total=False,
)


class JobSkillListRelationFilter(TypedDict, total=False):
    some: 'JobSkillWhereInput'
    none: 'JobSkillWhereInput'
    every: 'JobSkillWhereInput'


class JobSkillInclude(TypedDict, total=False):
    """JobSkill relational arguments"""
    job: Union[bool, 'JobPostingArgsFromJobSkill']
    skill: Union[bool, 'SkillArgsFromJobSkill']


class CompanyIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromJobSkill']


class CompanyArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromJobSkill']


class LocationArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    company: Union[bool, 'CompanyArgsFromJobSkill']
    location: Union[bool, 'LocationArgsFromJobSkill']
    skills: Union[bool, 'FindManyJobSkillArgsFromJobSkill']


class JobPostingArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromJobSkill']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromJobSkill']


class SkillArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    job: Union[bool, 'JobPostingArgsFromJobSkill']
    skill: Union[bool, 'SkillArgsFromJobSkill']


class JobSkillArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromJobSkill']


class OccupationArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    occupation: Union[bool, 'OccupationArgsFromJobSkill']
    skill: Union[bool, 'SkillArgsFromJobSkill']


class OccupationSkillArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromJobSkill']


class ResumeArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromJobSkill(TypedDict, total=False):
    """Relational arguments for JobSkill"""
    resume: Union[bool, 'ResumeArgsFromJobSkill']


class ResumeSkillArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromJobSkill(TypedDict, total=False):
    """Arguments for JobSkill"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManyJobSkillArgs = FindManyJobSkillArgsFromJobSkill
FindFirstJobSkillArgs = FindManyJobSkillArgsFromJobSkill


class JobSkillWhereInput(TypedDict, total=False):
    """JobSkill arguments for searching"""
    jobId: Union[_str, 'types.StringFilter']
    skillId: Union[_str, 'types.StringFilter']
    job: 'JobPostingRelationFilter'
    skill: 'SkillRelationFilter'

    # should be noted that AND and NOT should be Union['JobSkillWhereInput', List['JobSkillWhereInput']]
    # but this causes mypy to hang :/
    AND: List['JobSkillWhereInput']
    OR: List['JobSkillWhereInput']
    NOT: List['JobSkillWhereInput']



# aggregate JobSkill types


class JobSkillScalarWhereWithAggregatesInput(TypedDict, total=False):
    """JobSkill arguments for searching"""
    jobId: Union[_str, 'types.StringWithAggregatesFilter']
    skillId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['JobSkillScalarWhereWithAggregatesInput']
    OR: List['JobSkillScalarWhereWithAggregatesInput']
    NOT: List['JobSkillScalarWhereWithAggregatesInput']



class JobSkillGroupByOutput(TypedDict, total=False):
    jobId: _str
    skillId: _str
    _sum: 'JobSkillSumAggregateOutput'
    _avg: 'JobSkillAvgAggregateOutput'
    _min: 'JobSkillMinAggregateOutput'
    _max: 'JobSkillMaxAggregateOutput'
    _count: 'JobSkillCountAggregateOutput'


class JobSkillAvgAggregateOutput(TypedDict, total=False):
    """JobSkill output for aggregating averages"""


class JobSkillSumAggregateOutput(TypedDict, total=False):
    """JobSkill output for aggregating sums"""


class JobSkillScalarAggregateOutput(TypedDict, total=False):
    """JobSkill output including scalar fields"""
    jobId: _str
    skillId: _str


JobSkillMinAggregateOutput = JobSkillScalarAggregateOutput
JobSkillMaxAggregateOutput = JobSkillScalarAggregateOutput


class JobSkillMaxAggregateInput(TypedDict, total=False):
    """JobSkill input for aggregating by max"""
    jobId: bool
    skillId: bool


class JobSkillMinAggregateInput(TypedDict, total=False):
    """JobSkill input for aggregating by min"""
    jobId: bool
    skillId: bool


class JobSkillNumberAggregateInput(TypedDict, total=False):
    """JobSkill input for aggregating numbers"""


JobSkillAvgAggregateInput = JobSkillNumberAggregateInput
JobSkillSumAggregateInput = JobSkillNumberAggregateInput


JobSkillCountAggregateInput = TypedDict(
    'JobSkillCountAggregateInput',
    {
        'jobId': bool,
        'skillId': bool,
        '_all': bool,
    },
    total=False,
)

JobSkillCountAggregateOutput = TypedDict(
    'JobSkillCountAggregateOutput',
    {
        'jobId': int,
        'skillId': int,
        '_all': int,
    },
    total=False,
)


JobSkillKeys = Literal[
    'jobId',
    'skillId',
    'job',
    'skill',
]
JobSkillScalarFieldKeys = Literal[
    'jobId',
    'skillId',
]
JobSkillScalarFieldKeysT = TypeVar('JobSkillScalarFieldKeysT', bound=JobSkillScalarFieldKeys)

JobSkillRelationalFieldKeys = Literal[
        'job',
        'skill',
    ]

# Occupation types

class OccupationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Occupation create method"""
    id: _str
    description: Optional[_str]
    skills: 'OccupationSkillCreateManyNestedWithoutRelationsInput'


class OccupationCreateInput(OccupationOptionalCreateInput):
    """Required arguments to the Occupation create method"""
    title: _str
    source: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OccupationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Occupation create method, without relations"""
    id: _str
    description: Optional[_str]


class OccupationCreateWithoutRelationsInput(OccupationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Occupation create method, without relations"""
    title: _str
    source: _str

class OccupationConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'OccupationCreateWithoutRelationsInput'
    where: 'OccupationWhereUniqueInput'

class OccupationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OccupationCreateWithoutRelationsInput'
    connect: 'OccupationWhereUniqueInput'
    connect_or_create: 'OccupationConnectOrCreateWithoutRelationsInput'


class OccupationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OccupationCreateWithoutRelationsInput', List['OccupationCreateWithoutRelationsInput']]
    connect: Union['OccupationWhereUniqueInput', List['OccupationWhereUniqueInput']]
    connect_or_create: Union['OccupationConnectOrCreateWithoutRelationsInput', List['OccupationConnectOrCreateWithoutRelationsInput']]

_OccupationWhereUnique_id_Input = TypedDict(
    '_OccupationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

OccupationWhereUniqueInput = _OccupationWhereUnique_id_Input


class OccupationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    title: _str
    description: Optional[_str]
    source: _str
    skills: 'OccupationSkillUpdateManyWithoutRelationsInput'


class OccupationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    title: _str
    description: Optional[_str]
    source: _str


class OccupationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OccupationCreateWithoutRelationsInput']
    connect: List['OccupationWhereUniqueInput']
    connect_or_create: List['OccupationConnectOrCreateWithoutRelationsInput']
    set: List['OccupationWhereUniqueInput']
    disconnect: List['OccupationWhereUniqueInput']
    delete: List['OccupationWhereUniqueInput']

    # TODO
    # update: List['OccupationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OccupationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OccupationScalarWhereInput']
    # upsert: List['OccupationUpserteWithWhereUniqueWithoutRelationsInput']


class OccupationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OccupationCreateWithoutRelationsInput'
    connect: 'OccupationWhereUniqueInput'
    connect_or_create: 'OccupationConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OccupationUpdateInput'
    # upsert: 'OccupationUpsertWithoutRelationsInput'


class OccupationUpsertInput(TypedDict):
    create: 'OccupationCreateInput'
    update: 'OccupationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Occupation_id_OrderByInput = TypedDict(
    '_Occupation_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Occupation_title_OrderByInput = TypedDict(
    '_Occupation_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Occupation_description_OrderByInput = TypedDict(
    '_Occupation_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Occupation_source_OrderByInput = TypedDict(
    '_Occupation_source_OrderByInput',
    {
        'source': 'SortOrder',
    },
    total=True
)

_Occupation_RelevanceInner = TypedDict(
    '_Occupation_RelevanceInner',
    {
        'fields': 'List[OccupationScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Occupation_RelevanceOrderByInput = TypedDict(
    '_Occupation_RelevanceOrderByInput',
    {
        '_relevance': '_Occupation_RelevanceInner',
    },
    total=True
)

OccupationOrderByInput = Union[
    '_Occupation_id_OrderByInput',
    '_Occupation_title_OrderByInput',
    '_Occupation_description_OrderByInput',
    '_Occupation_source_OrderByInput',
    '_Occupation_RelevanceOrderByInput',
]



# recursive Occupation types
# TODO: cleanup these types



OccupationRelationFilter = TypedDict(
    'OccupationRelationFilter',
    {
        'is': 'OccupationWhereInput',
        'is_not': 'OccupationWhereInput',
    },
    total=False,
)


class OccupationListRelationFilter(TypedDict, total=False):
    some: 'OccupationWhereInput'
    none: 'OccupationWhereInput'
    every: 'OccupationWhereInput'


class OccupationInclude(TypedDict, total=False):
    """Occupation relational arguments"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromOccupation']


class CompanyIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromOccupation']


class CompanyArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromOccupation']


class LocationArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    company: Union[bool, 'CompanyArgsFromOccupation']
    location: Union[bool, 'LocationArgsFromOccupation']
    skills: Union[bool, 'FindManyJobSkillArgsFromOccupation']


class JobPostingArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromOccupation']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromOccupation']


class SkillArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    job: Union[bool, 'JobPostingArgsFromOccupation']
    skill: Union[bool, 'SkillArgsFromOccupation']


class JobSkillArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromOccupation']


class OccupationArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    occupation: Union[bool, 'OccupationArgsFromOccupation']
    skill: Union[bool, 'SkillArgsFromOccupation']


class OccupationSkillArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromOccupation']


class ResumeArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromOccupation(TypedDict, total=False):
    """Relational arguments for Occupation"""
    resume: Union[bool, 'ResumeArgsFromOccupation']


class ResumeSkillArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromOccupation(TypedDict, total=False):
    """Arguments for Occupation"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManyOccupationArgs = FindManyOccupationArgsFromOccupation
FindFirstOccupationArgs = FindManyOccupationArgsFromOccupation


class OccupationWhereInput(TypedDict, total=False):
    """Occupation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']
    skills: 'OccupationSkillListRelationFilter'

    # should be noted that AND and NOT should be Union['OccupationWhereInput', List['OccupationWhereInput']]
    # but this causes mypy to hang :/
    AND: List['OccupationWhereInput']
    OR: List['OccupationWhereInput']
    NOT: List['OccupationWhereInput']



# aggregate Occupation types


class OccupationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Occupation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OccupationScalarWhereWithAggregatesInput']
    OR: List['OccupationScalarWhereWithAggregatesInput']
    NOT: List['OccupationScalarWhereWithAggregatesInput']



class OccupationGroupByOutput(TypedDict, total=False):
    id: _str
    title: _str
    description: _str
    source: _str
    _sum: 'OccupationSumAggregateOutput'
    _avg: 'OccupationAvgAggregateOutput'
    _min: 'OccupationMinAggregateOutput'
    _max: 'OccupationMaxAggregateOutput'
    _count: 'OccupationCountAggregateOutput'


class OccupationAvgAggregateOutput(TypedDict, total=False):
    """Occupation output for aggregating averages"""


class OccupationSumAggregateOutput(TypedDict, total=False):
    """Occupation output for aggregating sums"""


class OccupationScalarAggregateOutput(TypedDict, total=False):
    """Occupation output including scalar fields"""
    id: _str
    title: _str
    description: _str
    source: _str


OccupationMinAggregateOutput = OccupationScalarAggregateOutput
OccupationMaxAggregateOutput = OccupationScalarAggregateOutput


class OccupationMaxAggregateInput(TypedDict, total=False):
    """Occupation input for aggregating by max"""
    id: bool
    title: bool
    description: bool
    source: bool


class OccupationMinAggregateInput(TypedDict, total=False):
    """Occupation input for aggregating by min"""
    id: bool
    title: bool
    description: bool
    source: bool


class OccupationNumberAggregateInput(TypedDict, total=False):
    """Occupation input for aggregating numbers"""


OccupationAvgAggregateInput = OccupationNumberAggregateInput
OccupationSumAggregateInput = OccupationNumberAggregateInput


OccupationCountAggregateInput = TypedDict(
    'OccupationCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'description': bool,
        'source': bool,
        '_all': bool,
    },
    total=False,
)

OccupationCountAggregateOutput = TypedDict(
    'OccupationCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'description': int,
        'source': int,
        '_all': int,
    },
    total=False,
)


OccupationKeys = Literal[
    'id',
    'title',
    'description',
    'source',
    'skills',
]
OccupationScalarFieldKeys = Literal[
    'id',
    'title',
    'description',
    'source',
]
OccupationScalarFieldKeysT = TypeVar('OccupationScalarFieldKeysT', bound=OccupationScalarFieldKeys)

OccupationRelationalFieldKeys = Literal[
        'skills',
    ]

# OccupationSkill types

class OccupationSkillOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the OccupationSkill create method"""
    occupationId: _str
    skillId: _str
    relationType: Optional[_str]
    skillType: Optional[_str]
    occupation: 'OccupationCreateNestedWithoutRelationsInput'
    skill: 'SkillCreateNestedWithoutRelationsInput'


class OccupationSkillCreateInput(OccupationSkillOptionalCreateInput):
    """Required arguments to the OccupationSkill create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OccupationSkillOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the OccupationSkill create method, without relations"""
    occupationId: _str
    skillId: _str
    relationType: Optional[_str]
    skillType: Optional[_str]


class OccupationSkillCreateWithoutRelationsInput(OccupationSkillOptionalCreateWithoutRelationsInput):
    """Required arguments to the OccupationSkill create method, without relations"""

class OccupationSkillConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'OccupationSkillCreateWithoutRelationsInput'
    where: 'OccupationSkillWhereUniqueInput'

class OccupationSkillCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OccupationSkillCreateWithoutRelationsInput'
    connect: 'OccupationSkillWhereUniqueInput'
    connect_or_create: 'OccupationSkillConnectOrCreateWithoutRelationsInput'


class OccupationSkillCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OccupationSkillCreateWithoutRelationsInput', List['OccupationSkillCreateWithoutRelationsInput']]
    connect: Union['OccupationSkillWhereUniqueInput', List['OccupationSkillWhereUniqueInput']]
    connect_or_create: Union['OccupationSkillConnectOrCreateWithoutRelationsInput', List['OccupationSkillConnectOrCreateWithoutRelationsInput']]

_OccupationSkillCompoundPrimaryKeyInner = TypedDict(
    '_OccupationSkillCompoundPrimaryKeyInner',
    {
        'occupationId': '_str',
        'skillId': '_str',
    },
    total=True
)

_OccupationSkillCompoundPrimaryKey = TypedDict(
    '_OccupationSkillCompoundPrimaryKey',
    {
        'occupationId_skillId': '_OccupationSkillCompoundPrimaryKeyInner',
    },
    total=True
)

OccupationSkillWhereUniqueInput = _OccupationSkillCompoundPrimaryKey


class OccupationSkillUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    relationType: Optional[_str]
    skillType: Optional[_str]
    occupation: 'OccupationUpdateOneWithoutRelationsInput'
    skill: 'SkillUpdateOneWithoutRelationsInput'


class OccupationSkillUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    relationType: Optional[_str]
    skillType: Optional[_str]


class OccupationSkillUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OccupationSkillCreateWithoutRelationsInput']
    connect: List['OccupationSkillWhereUniqueInput']
    connect_or_create: List['OccupationSkillConnectOrCreateWithoutRelationsInput']
    set: List['OccupationSkillWhereUniqueInput']
    disconnect: List['OccupationSkillWhereUniqueInput']
    delete: List['OccupationSkillWhereUniqueInput']

    # TODO
    # update: List['OccupationSkillUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OccupationSkillUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OccupationSkillScalarWhereInput']
    # upsert: List['OccupationSkillUpserteWithWhereUniqueWithoutRelationsInput']


class OccupationSkillUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OccupationSkillCreateWithoutRelationsInput'
    connect: 'OccupationSkillWhereUniqueInput'
    connect_or_create: 'OccupationSkillConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OccupationSkillUpdateInput'
    # upsert: 'OccupationSkillUpsertWithoutRelationsInput'


class OccupationSkillUpsertInput(TypedDict):
    create: 'OccupationSkillCreateInput'
    update: 'OccupationSkillUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_OccupationSkill_occupationId_OrderByInput = TypedDict(
    '_OccupationSkill_occupationId_OrderByInput',
    {
        'occupationId': 'SortOrder',
    },
    total=True
)

_OccupationSkill_skillId_OrderByInput = TypedDict(
    '_OccupationSkill_skillId_OrderByInput',
    {
        'skillId': 'SortOrder',
    },
    total=True
)

_OccupationSkill_relationType_OrderByInput = TypedDict(
    '_OccupationSkill_relationType_OrderByInput',
    {
        'relationType': 'SortOrder',
    },
    total=True
)

_OccupationSkill_skillType_OrderByInput = TypedDict(
    '_OccupationSkill_skillType_OrderByInput',
    {
        'skillType': 'SortOrder',
    },
    total=True
)

_OccupationSkill_RelevanceInner = TypedDict(
    '_OccupationSkill_RelevanceInner',
    {
        'fields': 'List[OccupationSkillScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_OccupationSkill_RelevanceOrderByInput = TypedDict(
    '_OccupationSkill_RelevanceOrderByInput',
    {
        '_relevance': '_OccupationSkill_RelevanceInner',
    },
    total=True
)

OccupationSkillOrderByInput = Union[
    '_OccupationSkill_occupationId_OrderByInput',
    '_OccupationSkill_skillId_OrderByInput',
    '_OccupationSkill_relationType_OrderByInput',
    '_OccupationSkill_skillType_OrderByInput',
    '_OccupationSkill_RelevanceOrderByInput',
]



# recursive OccupationSkill types
# TODO: cleanup these types



OccupationSkillRelationFilter = TypedDict(
    'OccupationSkillRelationFilter',
    {
        'is': 'OccupationSkillWhereInput',
        'is_not': 'OccupationSkillWhereInput',
    },
    total=False,
)


class OccupationSkillListRelationFilter(TypedDict, total=False):
    some: 'OccupationSkillWhereInput'
    none: 'OccupationSkillWhereInput'
    every: 'OccupationSkillWhereInput'


class OccupationSkillInclude(TypedDict, total=False):
    """OccupationSkill relational arguments"""
    occupation: Union[bool, 'OccupationArgsFromOccupationSkill']
    skill: Union[bool, 'SkillArgsFromOccupationSkill']


class CompanyIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromOccupationSkill']


class CompanyArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromOccupationSkill']


class LocationArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    company: Union[bool, 'CompanyArgsFromOccupationSkill']
    location: Union[bool, 'LocationArgsFromOccupationSkill']
    skills: Union[bool, 'FindManyJobSkillArgsFromOccupationSkill']


class JobPostingArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromOccupationSkill']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromOccupationSkill']


class SkillArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    job: Union[bool, 'JobPostingArgsFromOccupationSkill']
    skill: Union[bool, 'SkillArgsFromOccupationSkill']


class JobSkillArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromOccupationSkill']


class OccupationArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    occupation: Union[bool, 'OccupationArgsFromOccupationSkill']
    skill: Union[bool, 'SkillArgsFromOccupationSkill']


class OccupationSkillArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromOccupationSkill']


class ResumeArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromOccupationSkill(TypedDict, total=False):
    """Relational arguments for OccupationSkill"""
    resume: Union[bool, 'ResumeArgsFromOccupationSkill']


class ResumeSkillArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromOccupationSkill(TypedDict, total=False):
    """Arguments for OccupationSkill"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManyOccupationSkillArgs = FindManyOccupationSkillArgsFromOccupationSkill
FindFirstOccupationSkillArgs = FindManyOccupationSkillArgsFromOccupationSkill


class OccupationSkillWhereInput(TypedDict, total=False):
    """OccupationSkill arguments for searching"""
    occupationId: Union[_str, 'types.StringFilter']
    skillId: Union[_str, 'types.StringFilter']
    relationType: Union[None, _str, 'types.StringFilter']
    skillType: Union[None, _str, 'types.StringFilter']
    occupation: 'OccupationRelationFilter'
    skill: 'SkillRelationFilter'

    # should be noted that AND and NOT should be Union['OccupationSkillWhereInput', List['OccupationSkillWhereInput']]
    # but this causes mypy to hang :/
    AND: List['OccupationSkillWhereInput']
    OR: List['OccupationSkillWhereInput']
    NOT: List['OccupationSkillWhereInput']



# aggregate OccupationSkill types


class OccupationSkillScalarWhereWithAggregatesInput(TypedDict, total=False):
    """OccupationSkill arguments for searching"""
    occupationId: Union[_str, 'types.StringWithAggregatesFilter']
    skillId: Union[_str, 'types.StringWithAggregatesFilter']
    relationType: Union[_str, 'types.StringWithAggregatesFilter']
    skillType: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['OccupationSkillScalarWhereWithAggregatesInput']
    OR: List['OccupationSkillScalarWhereWithAggregatesInput']
    NOT: List['OccupationSkillScalarWhereWithAggregatesInput']



class OccupationSkillGroupByOutput(TypedDict, total=False):
    occupationId: _str
    skillId: _str
    relationType: _str
    skillType: _str
    _sum: 'OccupationSkillSumAggregateOutput'
    _avg: 'OccupationSkillAvgAggregateOutput'
    _min: 'OccupationSkillMinAggregateOutput'
    _max: 'OccupationSkillMaxAggregateOutput'
    _count: 'OccupationSkillCountAggregateOutput'


class OccupationSkillAvgAggregateOutput(TypedDict, total=False):
    """OccupationSkill output for aggregating averages"""


class OccupationSkillSumAggregateOutput(TypedDict, total=False):
    """OccupationSkill output for aggregating sums"""


class OccupationSkillScalarAggregateOutput(TypedDict, total=False):
    """OccupationSkill output including scalar fields"""
    occupationId: _str
    skillId: _str
    relationType: _str
    skillType: _str


OccupationSkillMinAggregateOutput = OccupationSkillScalarAggregateOutput
OccupationSkillMaxAggregateOutput = OccupationSkillScalarAggregateOutput


class OccupationSkillMaxAggregateInput(TypedDict, total=False):
    """OccupationSkill input for aggregating by max"""
    occupationId: bool
    skillId: bool
    relationType: bool
    skillType: bool


class OccupationSkillMinAggregateInput(TypedDict, total=False):
    """OccupationSkill input for aggregating by min"""
    occupationId: bool
    skillId: bool
    relationType: bool
    skillType: bool


class OccupationSkillNumberAggregateInput(TypedDict, total=False):
    """OccupationSkill input for aggregating numbers"""


OccupationSkillAvgAggregateInput = OccupationSkillNumberAggregateInput
OccupationSkillSumAggregateInput = OccupationSkillNumberAggregateInput


OccupationSkillCountAggregateInput = TypedDict(
    'OccupationSkillCountAggregateInput',
    {
        'occupationId': bool,
        'skillId': bool,
        'relationType': bool,
        'skillType': bool,
        '_all': bool,
    },
    total=False,
)

OccupationSkillCountAggregateOutput = TypedDict(
    'OccupationSkillCountAggregateOutput',
    {
        'occupationId': int,
        'skillId': int,
        'relationType': int,
        'skillType': int,
        '_all': int,
    },
    total=False,
)


OccupationSkillKeys = Literal[
    'occupationId',
    'skillId',
    'relationType',
    'skillType',
    'occupation',
    'skill',
]
OccupationSkillScalarFieldKeys = Literal[
    'occupationId',
    'skillId',
    'relationType',
    'skillType',
]
OccupationSkillScalarFieldKeysT = TypeVar('OccupationSkillScalarFieldKeysT', bound=OccupationSkillScalarFieldKeys)

OccupationSkillRelationalFieldKeys = Literal[
        'occupation',
        'skill',
    ]

# Resume types

class ResumeOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Resume create method"""
    id: _str
    name: Optional[_str]
    email: Optional[_str]
    phone: Optional[_str]
    createdAt: datetime.datetime
    skills: 'ResumeSkillCreateManyNestedWithoutRelationsInput'


class ResumeCreateInput(ResumeOptionalCreateInput):
    """Required arguments to the Resume create method"""
    rawText: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ResumeOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Resume create method, without relations"""
    id: _str
    name: Optional[_str]
    email: Optional[_str]
    phone: Optional[_str]
    createdAt: datetime.datetime


class ResumeCreateWithoutRelationsInput(ResumeOptionalCreateWithoutRelationsInput):
    """Required arguments to the Resume create method, without relations"""
    rawText: _str

class ResumeConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ResumeCreateWithoutRelationsInput'
    where: 'ResumeWhereUniqueInput'

class ResumeCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ResumeCreateWithoutRelationsInput'
    connect: 'ResumeWhereUniqueInput'
    connect_or_create: 'ResumeConnectOrCreateWithoutRelationsInput'


class ResumeCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ResumeCreateWithoutRelationsInput', List['ResumeCreateWithoutRelationsInput']]
    connect: Union['ResumeWhereUniqueInput', List['ResumeWhereUniqueInput']]
    connect_or_create: Union['ResumeConnectOrCreateWithoutRelationsInput', List['ResumeConnectOrCreateWithoutRelationsInput']]

_ResumeWhereUnique_id_Input = TypedDict(
    '_ResumeWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ResumeWhereUniqueInput = _ResumeWhereUnique_id_Input


class ResumeUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: Optional[_str]
    email: Optional[_str]
    phone: Optional[_str]
    rawText: _str
    createdAt: datetime.datetime
    skills: 'ResumeSkillUpdateManyWithoutRelationsInput'


class ResumeUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: Optional[_str]
    email: Optional[_str]
    phone: Optional[_str]
    rawText: _str
    createdAt: datetime.datetime


class ResumeUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ResumeCreateWithoutRelationsInput']
    connect: List['ResumeWhereUniqueInput']
    connect_or_create: List['ResumeConnectOrCreateWithoutRelationsInput']
    set: List['ResumeWhereUniqueInput']
    disconnect: List['ResumeWhereUniqueInput']
    delete: List['ResumeWhereUniqueInput']

    # TODO
    # update: List['ResumeUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ResumeUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ResumeScalarWhereInput']
    # upsert: List['ResumeUpserteWithWhereUniqueWithoutRelationsInput']


class ResumeUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ResumeCreateWithoutRelationsInput'
    connect: 'ResumeWhereUniqueInput'
    connect_or_create: 'ResumeConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ResumeUpdateInput'
    # upsert: 'ResumeUpsertWithoutRelationsInput'


class ResumeUpsertInput(TypedDict):
    create: 'ResumeCreateInput'
    update: 'ResumeUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Resume_id_OrderByInput = TypedDict(
    '_Resume_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Resume_name_OrderByInput = TypedDict(
    '_Resume_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Resume_email_OrderByInput = TypedDict(
    '_Resume_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Resume_phone_OrderByInput = TypedDict(
    '_Resume_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Resume_rawText_OrderByInput = TypedDict(
    '_Resume_rawText_OrderByInput',
    {
        'rawText': 'SortOrder',
    },
    total=True
)

_Resume_createdAt_OrderByInput = TypedDict(
    '_Resume_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Resume_RelevanceInner = TypedDict(
    '_Resume_RelevanceInner',
    {
        'fields': 'List[ResumeScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Resume_RelevanceOrderByInput = TypedDict(
    '_Resume_RelevanceOrderByInput',
    {
        '_relevance': '_Resume_RelevanceInner',
    },
    total=True
)

ResumeOrderByInput = Union[
    '_Resume_id_OrderByInput',
    '_Resume_name_OrderByInput',
    '_Resume_email_OrderByInput',
    '_Resume_phone_OrderByInput',
    '_Resume_rawText_OrderByInput',
    '_Resume_createdAt_OrderByInput',
    '_Resume_RelevanceOrderByInput',
]



# recursive Resume types
# TODO: cleanup these types



ResumeRelationFilter = TypedDict(
    'ResumeRelationFilter',
    {
        'is': 'ResumeWhereInput',
        'is_not': 'ResumeWhereInput',
    },
    total=False,
)


class ResumeListRelationFilter(TypedDict, total=False):
    some: 'ResumeWhereInput'
    none: 'ResumeWhereInput'
    every: 'ResumeWhereInput'


class ResumeInclude(TypedDict, total=False):
    """Resume relational arguments"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromResume']


class CompanyIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromResume']


class CompanyArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromResume']


class LocationArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    company: Union[bool, 'CompanyArgsFromResume']
    location: Union[bool, 'LocationArgsFromResume']
    skills: Union[bool, 'FindManyJobSkillArgsFromResume']


class JobPostingArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromResume']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromResume']


class SkillArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    job: Union[bool, 'JobPostingArgsFromResume']
    skill: Union[bool, 'SkillArgsFromResume']


class JobSkillArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromResume']


class OccupationArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    occupation: Union[bool, 'OccupationArgsFromResume']
    skill: Union[bool, 'SkillArgsFromResume']


class OccupationSkillArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromResume']


class ResumeArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromResume(TypedDict, total=False):
    """Relational arguments for Resume"""
    resume: Union[bool, 'ResumeArgsFromResume']


class ResumeSkillArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromResume(TypedDict, total=False):
    """Arguments for Resume"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManyResumeArgs = FindManyResumeArgsFromResume
FindFirstResumeArgs = FindManyResumeArgsFromResume


class ResumeWhereInput(TypedDict, total=False):
    """Resume arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    rawText: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    skills: 'ResumeSkillListRelationFilter'

    # should be noted that AND and NOT should be Union['ResumeWhereInput', List['ResumeWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ResumeWhereInput']
    OR: List['ResumeWhereInput']
    NOT: List['ResumeWhereInput']



# aggregate Resume types


class ResumeScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Resume arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    rawText: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ResumeScalarWhereWithAggregatesInput']
    OR: List['ResumeScalarWhereWithAggregatesInput']
    NOT: List['ResumeScalarWhereWithAggregatesInput']



class ResumeGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    email: _str
    phone: _str
    rawText: _str
    createdAt: datetime.datetime
    _sum: 'ResumeSumAggregateOutput'
    _avg: 'ResumeAvgAggregateOutput'
    _min: 'ResumeMinAggregateOutput'
    _max: 'ResumeMaxAggregateOutput'
    _count: 'ResumeCountAggregateOutput'


class ResumeAvgAggregateOutput(TypedDict, total=False):
    """Resume output for aggregating averages"""


class ResumeSumAggregateOutput(TypedDict, total=False):
    """Resume output for aggregating sums"""


class ResumeScalarAggregateOutput(TypedDict, total=False):
    """Resume output including scalar fields"""
    id: _str
    name: _str
    email: _str
    phone: _str
    rawText: _str
    createdAt: datetime.datetime


ResumeMinAggregateOutput = ResumeScalarAggregateOutput
ResumeMaxAggregateOutput = ResumeScalarAggregateOutput


class ResumeMaxAggregateInput(TypedDict, total=False):
    """Resume input for aggregating by max"""
    id: bool
    name: bool
    email: bool
    phone: bool
    rawText: bool
    createdAt: bool


class ResumeMinAggregateInput(TypedDict, total=False):
    """Resume input for aggregating by min"""
    id: bool
    name: bool
    email: bool
    phone: bool
    rawText: bool
    createdAt: bool


class ResumeNumberAggregateInput(TypedDict, total=False):
    """Resume input for aggregating numbers"""


ResumeAvgAggregateInput = ResumeNumberAggregateInput
ResumeSumAggregateInput = ResumeNumberAggregateInput


ResumeCountAggregateInput = TypedDict(
    'ResumeCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'email': bool,
        'phone': bool,
        'rawText': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

ResumeCountAggregateOutput = TypedDict(
    'ResumeCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'email': int,
        'phone': int,
        'rawText': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


ResumeKeys = Literal[
    'id',
    'name',
    'email',
    'phone',
    'rawText',
    'createdAt',
    'skills',
]
ResumeScalarFieldKeys = Literal[
    'id',
    'name',
    'email',
    'phone',
    'rawText',
    'createdAt',
]
ResumeScalarFieldKeysT = TypeVar('ResumeScalarFieldKeysT', bound=ResumeScalarFieldKeys)

ResumeRelationalFieldKeys = Literal[
        'skills',
    ]

# ResumeSkill types

class ResumeSkillOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ResumeSkill create method"""
    id: _str
    resume: 'ResumeCreateNestedWithoutRelationsInput'
    resumeId: _str
    canonicalSkillId: Optional[_str]


class ResumeSkillCreateInput(ResumeSkillOptionalCreateInput):
    """Required arguments to the ResumeSkill create method"""
    skillName: _str
    source: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ResumeSkillOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ResumeSkill create method, without relations"""
    id: _str
    resumeId: _str
    canonicalSkillId: Optional[_str]


class ResumeSkillCreateWithoutRelationsInput(ResumeSkillOptionalCreateWithoutRelationsInput):
    """Required arguments to the ResumeSkill create method, without relations"""
    skillName: _str
    source: _str

class ResumeSkillConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ResumeSkillCreateWithoutRelationsInput'
    where: 'ResumeSkillWhereUniqueInput'

class ResumeSkillCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ResumeSkillCreateWithoutRelationsInput'
    connect: 'ResumeSkillWhereUniqueInput'
    connect_or_create: 'ResumeSkillConnectOrCreateWithoutRelationsInput'


class ResumeSkillCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ResumeSkillCreateWithoutRelationsInput', List['ResumeSkillCreateWithoutRelationsInput']]
    connect: Union['ResumeSkillWhereUniqueInput', List['ResumeSkillWhereUniqueInput']]
    connect_or_create: Union['ResumeSkillConnectOrCreateWithoutRelationsInput', List['ResumeSkillConnectOrCreateWithoutRelationsInput']]

_ResumeSkillWhereUnique_id_Input = TypedDict(
    '_ResumeSkillWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ResumeSkillWhereUniqueInput = _ResumeSkillWhereUnique_id_Input


class ResumeSkillUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    resume: 'ResumeUpdateOneWithoutRelationsInput'
    skillName: _str
    canonicalSkillId: Optional[_str]
    source: _str


class ResumeSkillUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    skillName: _str
    canonicalSkillId: Optional[_str]
    source: _str


class ResumeSkillUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ResumeSkillCreateWithoutRelationsInput']
    connect: List['ResumeSkillWhereUniqueInput']
    connect_or_create: List['ResumeSkillConnectOrCreateWithoutRelationsInput']
    set: List['ResumeSkillWhereUniqueInput']
    disconnect: List['ResumeSkillWhereUniqueInput']
    delete: List['ResumeSkillWhereUniqueInput']

    # TODO
    # update: List['ResumeSkillUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ResumeSkillUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ResumeSkillScalarWhereInput']
    # upsert: List['ResumeSkillUpserteWithWhereUniqueWithoutRelationsInput']


class ResumeSkillUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ResumeSkillCreateWithoutRelationsInput'
    connect: 'ResumeSkillWhereUniqueInput'
    connect_or_create: 'ResumeSkillConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ResumeSkillUpdateInput'
    # upsert: 'ResumeSkillUpsertWithoutRelationsInput'


class ResumeSkillUpsertInput(TypedDict):
    create: 'ResumeSkillCreateInput'
    update: 'ResumeSkillUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ResumeSkill_id_OrderByInput = TypedDict(
    '_ResumeSkill_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ResumeSkill_resumeId_OrderByInput = TypedDict(
    '_ResumeSkill_resumeId_OrderByInput',
    {
        'resumeId': 'SortOrder',
    },
    total=True
)

_ResumeSkill_skillName_OrderByInput = TypedDict(
    '_ResumeSkill_skillName_OrderByInput',
    {
        'skillName': 'SortOrder',
    },
    total=True
)

_ResumeSkill_canonicalSkillId_OrderByInput = TypedDict(
    '_ResumeSkill_canonicalSkillId_OrderByInput',
    {
        'canonicalSkillId': 'SortOrder',
    },
    total=True
)

_ResumeSkill_source_OrderByInput = TypedDict(
    '_ResumeSkill_source_OrderByInput',
    {
        'source': 'SortOrder',
    },
    total=True
)

_ResumeSkill_RelevanceInner = TypedDict(
    '_ResumeSkill_RelevanceInner',
    {
        'fields': 'List[ResumeSkillScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ResumeSkill_RelevanceOrderByInput = TypedDict(
    '_ResumeSkill_RelevanceOrderByInput',
    {
        '_relevance': '_ResumeSkill_RelevanceInner',
    },
    total=True
)

ResumeSkillOrderByInput = Union[
    '_ResumeSkill_id_OrderByInput',
    '_ResumeSkill_resumeId_OrderByInput',
    '_ResumeSkill_skillName_OrderByInput',
    '_ResumeSkill_canonicalSkillId_OrderByInput',
    '_ResumeSkill_source_OrderByInput',
    '_ResumeSkill_RelevanceOrderByInput',
]



# recursive ResumeSkill types
# TODO: cleanup these types



ResumeSkillRelationFilter = TypedDict(
    'ResumeSkillRelationFilter',
    {
        'is': 'ResumeSkillWhereInput',
        'is_not': 'ResumeSkillWhereInput',
    },
    total=False,
)


class ResumeSkillListRelationFilter(TypedDict, total=False):
    some: 'ResumeSkillWhereInput'
    none: 'ResumeSkillWhereInput'
    every: 'ResumeSkillWhereInput'


class ResumeSkillInclude(TypedDict, total=False):
    """ResumeSkill relational arguments"""
    resume: Union[bool, 'ResumeArgsFromResumeSkill']


class CompanyIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromResumeSkill']


class CompanyArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'CompanyIncludeFromCompany'


class FindManyCompanyArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['CompanyOrderByInput', List['CompanyOrderByInput']]
    where: 'CompanyWhereInput'
    cursor: 'CompanyWhereUniqueInput'
    distinct: List['CompanyScalarFieldKeys']
    include: 'CompanyIncludeFromCompany'


class LocationIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    jobs: Union[bool, 'FindManyJobPostingArgsFromResumeSkill']


class LocationArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'LocationIncludeFromLocation'


class FindManyLocationArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['LocationOrderByInput', List['LocationOrderByInput']]
    where: 'LocationWhereInput'
    cursor: 'LocationWhereUniqueInput'
    distinct: List['LocationScalarFieldKeys']
    include: 'LocationIncludeFromLocation'


class JobPostingIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    company: Union[bool, 'CompanyArgsFromResumeSkill']
    location: Union[bool, 'LocationArgsFromResumeSkill']
    skills: Union[bool, 'FindManyJobSkillArgsFromResumeSkill']


class JobPostingArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'JobPostingIncludeFromJobPosting'


class FindManyJobPostingArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['JobPostingOrderByInput', List['JobPostingOrderByInput']]
    where: 'JobPostingWhereInput'
    cursor: 'JobPostingWhereUniqueInput'
    distinct: List['JobPostingScalarFieldKeys']
    include: 'JobPostingIncludeFromJobPosting'


class SkillIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    skillsInJobs: Union[bool, 'FindManyJobSkillArgsFromResumeSkill']
    occupationSkills: Union[bool, 'FindManyOccupationSkillArgsFromResumeSkill']


class SkillArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'SkillIncludeFromSkill'


class FindManySkillArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['SkillOrderByInput', List['SkillOrderByInput']]
    where: 'SkillWhereInput'
    cursor: 'SkillWhereUniqueInput'
    distinct: List['SkillScalarFieldKeys']
    include: 'SkillIncludeFromSkill'


class JobSkillIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    job: Union[bool, 'JobPostingArgsFromResumeSkill']
    skill: Union[bool, 'SkillArgsFromResumeSkill']


class JobSkillArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'JobSkillIncludeFromJobSkill'


class FindManyJobSkillArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['JobSkillOrderByInput', List['JobSkillOrderByInput']]
    where: 'JobSkillWhereInput'
    cursor: 'JobSkillWhereUniqueInput'
    distinct: List['JobSkillScalarFieldKeys']
    include: 'JobSkillIncludeFromJobSkill'


class OccupationIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    skills: Union[bool, 'FindManyOccupationSkillArgsFromResumeSkill']


class OccupationArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'OccupationIncludeFromOccupation'


class FindManyOccupationArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['OccupationOrderByInput', List['OccupationOrderByInput']]
    where: 'OccupationWhereInput'
    cursor: 'OccupationWhereUniqueInput'
    distinct: List['OccupationScalarFieldKeys']
    include: 'OccupationIncludeFromOccupation'


class OccupationSkillIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    occupation: Union[bool, 'OccupationArgsFromResumeSkill']
    skill: Union[bool, 'SkillArgsFromResumeSkill']


class OccupationSkillArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'OccupationSkillIncludeFromOccupationSkill'


class FindManyOccupationSkillArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['OccupationSkillOrderByInput', List['OccupationSkillOrderByInput']]
    where: 'OccupationSkillWhereInput'
    cursor: 'OccupationSkillWhereUniqueInput'
    distinct: List['OccupationSkillScalarFieldKeys']
    include: 'OccupationSkillIncludeFromOccupationSkill'


class ResumeIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    skills: Union[bool, 'FindManyResumeSkillArgsFromResumeSkill']


class ResumeArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'ResumeIncludeFromResume'


class FindManyResumeArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['ResumeOrderByInput', List['ResumeOrderByInput']]
    where: 'ResumeWhereInput'
    cursor: 'ResumeWhereUniqueInput'
    distinct: List['ResumeScalarFieldKeys']
    include: 'ResumeIncludeFromResume'


class ResumeSkillIncludeFromResumeSkill(TypedDict, total=False):
    """Relational arguments for ResumeSkill"""
    resume: Union[bool, 'ResumeArgsFromResumeSkill']


class ResumeSkillArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    include: 'ResumeSkillIncludeFromResumeSkill'


class FindManyResumeSkillArgsFromResumeSkill(TypedDict, total=False):
    """Arguments for ResumeSkill"""
    take: int
    skip: int
    order_by: Union['ResumeSkillOrderByInput', List['ResumeSkillOrderByInput']]
    where: 'ResumeSkillWhereInput'
    cursor: 'ResumeSkillWhereUniqueInput'
    distinct: List['ResumeSkillScalarFieldKeys']
    include: 'ResumeSkillIncludeFromResumeSkill'




FindManyResumeSkillArgs = FindManyResumeSkillArgsFromResumeSkill
FindFirstResumeSkillArgs = FindManyResumeSkillArgsFromResumeSkill


class ResumeSkillWhereInput(TypedDict, total=False):
    """ResumeSkill arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    resume: 'ResumeRelationFilter'
    resumeId: Union[_str, 'types.StringFilter']
    skillName: Union[_str, 'types.StringFilter']
    canonicalSkillId: Union[None, _str, 'types.StringFilter']
    source: Union[_str, 'types.StringFilter']

    # should be noted that AND and NOT should be Union['ResumeSkillWhereInput', List['ResumeSkillWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ResumeSkillWhereInput']
    OR: List['ResumeSkillWhereInput']
    NOT: List['ResumeSkillWhereInput']



# aggregate ResumeSkill types


class ResumeSkillScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ResumeSkill arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    resumeId: Union[_str, 'types.StringWithAggregatesFilter']
    skillName: Union[_str, 'types.StringWithAggregatesFilter']
    canonicalSkillId: Union[_str, 'types.StringWithAggregatesFilter']
    source: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ResumeSkillScalarWhereWithAggregatesInput']
    OR: List['ResumeSkillScalarWhereWithAggregatesInput']
    NOT: List['ResumeSkillScalarWhereWithAggregatesInput']



class ResumeSkillGroupByOutput(TypedDict, total=False):
    id: _str
    resumeId: _str
    skillName: _str
    canonicalSkillId: _str
    source: _str
    _sum: 'ResumeSkillSumAggregateOutput'
    _avg: 'ResumeSkillAvgAggregateOutput'
    _min: 'ResumeSkillMinAggregateOutput'
    _max: 'ResumeSkillMaxAggregateOutput'
    _count: 'ResumeSkillCountAggregateOutput'


class ResumeSkillAvgAggregateOutput(TypedDict, total=False):
    """ResumeSkill output for aggregating averages"""


class ResumeSkillSumAggregateOutput(TypedDict, total=False):
    """ResumeSkill output for aggregating sums"""


class ResumeSkillScalarAggregateOutput(TypedDict, total=False):
    """ResumeSkill output including scalar fields"""
    id: _str
    resumeId: _str
    skillName: _str
    canonicalSkillId: _str
    source: _str


ResumeSkillMinAggregateOutput = ResumeSkillScalarAggregateOutput
ResumeSkillMaxAggregateOutput = ResumeSkillScalarAggregateOutput


class ResumeSkillMaxAggregateInput(TypedDict, total=False):
    """ResumeSkill input for aggregating by max"""
    id: bool
    resumeId: bool
    skillName: bool
    canonicalSkillId: bool
    source: bool


class ResumeSkillMinAggregateInput(TypedDict, total=False):
    """ResumeSkill input for aggregating by min"""
    id: bool
    resumeId: bool
    skillName: bool
    canonicalSkillId: bool
    source: bool


class ResumeSkillNumberAggregateInput(TypedDict, total=False):
    """ResumeSkill input for aggregating numbers"""


ResumeSkillAvgAggregateInput = ResumeSkillNumberAggregateInput
ResumeSkillSumAggregateInput = ResumeSkillNumberAggregateInput


ResumeSkillCountAggregateInput = TypedDict(
    'ResumeSkillCountAggregateInput',
    {
        'id': bool,
        'resumeId': bool,
        'skillName': bool,
        'canonicalSkillId': bool,
        'source': bool,
        '_all': bool,
    },
    total=False,
)

ResumeSkillCountAggregateOutput = TypedDict(
    'ResumeSkillCountAggregateOutput',
    {
        'id': int,
        'resumeId': int,
        'skillName': int,
        'canonicalSkillId': int,
        'source': int,
        '_all': int,
    },
    total=False,
)


ResumeSkillKeys = Literal[
    'id',
    'resume',
    'resumeId',
    'skillName',
    'canonicalSkillId',
    'source',
]
ResumeSkillScalarFieldKeys = Literal[
    'id',
    'resumeId',
    'skillName',
    'canonicalSkillId',
    'source',
]
ResumeSkillScalarFieldKeysT = TypeVar('ResumeSkillScalarFieldKeysT', bound=ResumeSkillScalarFieldKeys)

ResumeSkillRelationalFieldKeys = Literal[
        'resume',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields