# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class CompanyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Company]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Company.prisma().query_raw(
            'SELECT * FROM Company WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Company
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Company.prisma().query_first(
            'SELECT * FROM Company WHERE name = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CompanyCreateInput,
        include: Optional[types.CompanyInclude] = None
    ) -> _PrismaModelT:
        """Create a new Company record.

        Parameters
        ----------
        data
            Company record data
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The created Company record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Company record from just the required fields
        company = await Company.prisma().create(
            data={
                # data to create a Company record
                'name': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CompanyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Company records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Company record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Company.prisma().create_many(
            data=[
                {
                    # data to create a Company record
                    'name': 'bbehjachib',
                },
                {
                    # data to create a Company record
                    'name': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Company record.

        Parameters
        ----------
        where
            Company filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The deleted Company record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().delete(
            where={
                'id': 'dgiiaaijj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Company record.

        Parameters
        ----------
        where
            Company filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The found Company record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().find_unique(
            where={
                'id': 'bfaiacjjfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Company record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Company filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The found Company record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().find_unique_or_raise(
            where={
                'id': 'eigcfgbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Company records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Company records returned
        skip
            Ignore the first N results
        where
            Company filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Company]
            The list of all Company records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Company records
        companys = await Company.prisma().find_many(take=10)

        # find the first 5 Company records ordered by the website field
        companys = await Company.prisma().find_many(
            take=5,
            order={
                'website': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Company record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Company filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Company
            The first Company record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Company record ordered by the createdAt field
        company = await Company.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Company record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Company filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Company
            The first Company record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Company record ordered by the id field
        company = await Company.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CompanyUpdateInput,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Company record.

        Parameters
        ----------
        data
            Company record data specifying what to update
        where
            Company filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The updated Company record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        company = await Company.prisma().update(
            where={
                'id': 'bagcfbhiig',
            },
            data={
                # data to update the Company record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CompanyWhereUniqueInput,
        data: types.CompanyUpsertInput,
        include: Optional[types.CompanyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Company filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The created or updated Company record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().upsert(
            where={
                'id': 'cghideieh',
            },
            data={
                'create': {
                    'id': 'cghideieh',
                    'name': 'cadfabfehe',
                },
                'update': {
                    'name': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CompanyUpdateManyMutationInput,
        where: types.CompanyWhereInput,
    ) -> int:
        """Update multiple Company records

        Parameters
        ----------
        data
            Company data to update the selected Company records to
        where
            Filter to select the Company records to update

        Returns
        -------
        int
            The total number of Company records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Company records
        total = await Company.prisma().update_many(
            data={
                'name': 'biabhbdai'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Company records present in the database

        Parameters
        ----------
        select
            Select the Company fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Company filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Company.prisma().count()

        # results: prisma.types.CompanyCountAggregateOutput
        results = await Company.prisma().count(
            select={
                '_all': True,
                'website': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CompanyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> types.CompanyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CompanyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> Union[int, types.CompanyCountAggregateOutput]:
        """Count the number of Company records present in the database

        Parameters
        ----------
        select
            Select the Company fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Company filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Company.prisma().count()

        # results: prisma.types.CompanyCountAggregateOutput
        results = await Company.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CompanyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CompanyWhereInput] = None
    ) -> int:
        """Delete multiple Company records.

        Parameters
        ----------
        where
            Optional Company filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Company records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Company records
        total = await Company.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CompanyScalarFieldKeysT'],
        *,
        where: Optional['types.CompanyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CompanyAvgAggregateInput'] = None,
        sum: Optional['types.CompanySumAggregateInput'] = None,
        min: Optional['types.CompanyMinAggregateInput'] = None,
        max: Optional['types.CompanyMaxAggregateInput'] = None,
        having: Optional['types.CompanyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CompanyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CompanyScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.CompanyScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.CompanyGroupByOutput']:
        """Group Company records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Company fields to group records by
        where
            Company filter to select records
        take
            Limit the maximum number of Company records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CompanyGroupByOutput]
            A list of dictionaries representing the Company record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Company records by id values
        # and count how many records are in each group
        results = await Company.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LocationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Location]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Location.prisma().query_raw(
            'SELECT * FROM Location WHERE id = $1',
            'idghgaicb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Location
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Location.prisma().query_first(
            'SELECT * FROM Location WHERE city = $1',
            'fjfddhigg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LocationCreateInput,
        include: Optional[types.LocationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Location record.

        Parameters
        ----------
        data
            Location record data
        include
            Specifies which relations should be loaded on the returned Location model

        Returns
        -------
        prisma.models.Location
            The created Location record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Location record from just the required fields
        location = await Location.prisma().create(
            data={
                # data to create a Location record
                'country': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LocationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Location records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Location record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Location.prisma().create_many(
            data=[
                {
                    # data to create a Location record
                    'country': 'cbbbjbfcii',
                },
                {
                    # data to create a Location record
                    'country': 'bbejhfidcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LocationWhereUniqueInput,
        include: Optional[types.LocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Location record.

        Parameters
        ----------
        where
            Location filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Location model

        Returns
        -------
        prisma.models.Location
            The deleted Location record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        location = await Location.prisma().delete(
            where={
                'id': 'bgeecijdgg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LocationWhereUniqueInput,
        include: Optional[types.LocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Location record.

        Parameters
        ----------
        where
            Location filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Location model

        Returns
        -------
        prisma.models.Location
            The found Location record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        location = await Location.prisma().find_unique(
            where={
                'id': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LocationWhereUniqueInput,
        include: Optional[types.LocationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Location record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Location filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Location model

        Returns
        -------
        prisma.models.Location
            The found Location record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        location = await Location.prisma().find_unique_or_raise(
            where={
                'id': 'bgehebiafc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LocationWhereInput] = None,
        cursor: Optional[types.LocationWhereUniqueInput] = None,
        include: Optional[types.LocationInclude] = None,
        order: Optional[Union[types.LocationOrderByInput, List[types.LocationOrderByInput]]] = None,
        distinct: Optional[List[types.LocationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Location records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Location records returned
        skip
            Ignore the first N results
        where
            Location filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Location model
        order
            Order the returned Location records by any field
        distinct
            Filter Location records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Location]
            The list of all Location records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Location records
        locations = await Location.prisma().find_many(take=10)

        # find the first 5 Location records ordered by the region field
        locations = await Location.prisma().find_many(
            take=5,
            order={
                'region': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LocationWhereInput] = None,
        cursor: Optional[types.LocationWhereUniqueInput] = None,
        include: Optional[types.LocationInclude] = None,
        order: Optional[Union[types.LocationOrderByInput, List[types.LocationOrderByInput]]] = None,
        distinct: Optional[List[types.LocationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Location record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Location filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Location model
        order
            Order the returned Location records by any field
        distinct
            Filter Location records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Location
            The first Location record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Location record ordered by the country field
        location = await Location.prisma().find_first(
            skip=1,
            order={
                'country': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LocationWhereInput] = None,
        cursor: Optional[types.LocationWhereUniqueInput] = None,
        include: Optional[types.LocationInclude] = None,
        order: Optional[Union[types.LocationOrderByInput, List[types.LocationOrderByInput]]] = None,
        distinct: Optional[List[types.LocationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Location record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Location filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Location model
        order
            Order the returned Location records by any field
        distinct
            Filter Location records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Location
            The first Location record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Location record ordered by the latitude field
        location = await Location.prisma().find_first_or_raise(
            skip=1,
            order={
                'latitude': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LocationUpdateInput,
        where: types.LocationWhereUniqueInput,
        include: Optional[types.LocationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Location record.

        Parameters
        ----------
        data
            Location record data specifying what to update
        where
            Location filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Location model

        Returns
        -------
        prisma.models.Location
            The updated Location record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        location = await Location.prisma().update(
            where={
                'id': 'bghffegacj',
            },
            data={
                # data to update the Location record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LocationWhereUniqueInput,
        data: types.LocationUpsertInput,
        include: Optional[types.LocationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Location filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Location model

        Returns
        -------
        prisma.models.Location
            The created or updated Location record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        location = await Location.prisma().upsert(
            where={
                'id': 'bhghchehcc',
            },
            data={
                'create': {
                    'id': 'bhghchehcc',
                    'country': 'bbejhfidcb',
                },
                'update': {
                    'country': 'bbejhfidcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LocationUpdateManyMutationInput,
        where: types.LocationWhereInput,
    ) -> int:
        """Update multiple Location records

        Parameters
        ----------
        data
            Location data to update the selected Location records to
        where
            Filter to select the Location records to update

        Returns
        -------
        int
            The total number of Location records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Location records
        total = await Location.prisma().update_many(
            data={
                'longitude': 326272115.134320
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LocationWhereInput] = None,
        cursor: Optional[types.LocationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Location records present in the database

        Parameters
        ----------
        select
            Select the Location fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Location filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LocationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Location.prisma().count()

        # results: prisma.types.LocationCountAggregateOutput
        results = await Location.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LocationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LocationWhereInput] = None,
        cursor: Optional[types.LocationWhereUniqueInput] = None,
    ) -> types.LocationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LocationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LocationWhereInput] = None,
        cursor: Optional[types.LocationWhereUniqueInput] = None,
    ) -> Union[int, types.LocationCountAggregateOutput]:
        """Count the number of Location records present in the database

        Parameters
        ----------
        select
            Select the Location fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Location filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LocationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Location.prisma().count()

        # results: prisma.types.LocationCountAggregateOutput
        results = await Location.prisma().count(
            select={
                '_all': True,
                'city': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LocationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LocationWhereInput] = None
    ) -> int:
        """Delete multiple Location records.

        Parameters
        ----------
        where
            Optional Location filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Location records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Location records
        total = await Location.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LocationScalarFieldKeysT'],
        *,
        where: Optional['types.LocationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LocationAvgAggregateInput'] = None,
        sum: Optional['types.LocationSumAggregateInput'] = None,
        min: Optional['types.LocationMinAggregateInput'] = None,
        max: Optional['types.LocationMaxAggregateInput'] = None,
        having: Optional['types.LocationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LocationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LocationScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.LocationScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.LocationGroupByOutput']:
        """Group Location records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Location fields to group records by
        where
            Location filter to select records
        take
            Limit the maximum number of Location records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LocationGroupByOutput]
            A list of dictionaries representing the Location record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Location records by region values
        # and count how many records are in each group
        results = await Location.prisma().group_by(
            ['region'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class JobPostingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.JobPosting]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await JobPosting.prisma().query_raw(
            'SELECT * FROM JobPosting WHERE id = $1',
            'ghfhiafcb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.JobPosting
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await JobPosting.prisma().query_first(
            'SELECT * FROM JobPosting WHERE jobId = $1',
            'heejgedji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.JobPostingCreateInput,
        include: Optional[types.JobPostingInclude] = None
    ) -> _PrismaModelT:
        """Create a new JobPosting record.

        Parameters
        ----------
        data
            JobPosting record data
        include
            Specifies which relations should be loaded on the returned JobPosting model

        Returns
        -------
        prisma.models.JobPosting
            The created JobPosting record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a JobPosting record from just the required fields
        jobposting = await JobPosting.prisma().create(
            data={
                # data to create a JobPosting record
                'jobId': 'bjgjgibgbf',
                'title': 'bbbgbhfjge',
                'description': 'igbehcbab',
                'url': 'bdadaadhag',
                'companyId': 'bgiggdidbf',
                'locationId': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.JobPostingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple JobPosting records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of JobPosting record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await JobPosting.prisma().create_many(
            data=[
                {
                    # data to create a JobPosting record
                    'jobId': 'bigibebcib',
                    'title': 'bigaiehgcc',
                    'description': 'beeifcbebf',
                    'url': 'bgcigfahea',
                    'companyId': 'bcejgaggif',
                    'locationId': 'idfjadbcc',
                },
                {
                    # data to create a JobPosting record
                    'jobId': 'hgdhbjhhj',
                    'title': 'ecjjjfbae',
                    'description': 'bhhfibbigf',
                    'url': 'ijdbeffgg',
                    'companyId': 'jjfeafhfj',
                    'locationId': 'cbachdgfce',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.JobPostingWhereUniqueInput,
        include: Optional[types.JobPostingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single JobPosting record.

        Parameters
        ----------
        where
            JobPosting filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned JobPosting model

        Returns
        -------
        prisma.models.JobPosting
            The deleted JobPosting record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobposting = await JobPosting.prisma().delete(
            where={
                'id': 'chbfcacbd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.JobPostingWhereUniqueInput,
        include: Optional[types.JobPostingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique JobPosting record.

        Parameters
        ----------
        where
            JobPosting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JobPosting model

        Returns
        -------
        prisma.models.JobPosting
            The found JobPosting record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobposting = await JobPosting.prisma().find_unique(
            where={
                'id': 'efggddide',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.JobPostingWhereUniqueInput,
        include: Optional[types.JobPostingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique JobPosting record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            JobPosting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JobPosting model

        Returns
        -------
        prisma.models.JobPosting
            The found JobPosting record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobposting = await JobPosting.prisma().find_unique_or_raise(
            where={
                'id': 'caficfigfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobPostingWhereInput] = None,
        cursor: Optional[types.JobPostingWhereUniqueInput] = None,
        include: Optional[types.JobPostingInclude] = None,
        order: Optional[Union[types.JobPostingOrderByInput, List[types.JobPostingOrderByInput]]] = None,
        distinct: Optional[List[types.JobPostingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple JobPosting records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of JobPosting records returned
        skip
            Ignore the first N results
        where
            JobPosting filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobPosting model
        order
            Order the returned JobPosting records by any field
        distinct
            Filter JobPosting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.JobPosting]
            The list of all JobPosting records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 JobPosting records
        jobpostings = await JobPosting.prisma().find_many(take=10)

        # find the first 5 JobPosting records ordered by the title field
        jobpostings = await JobPosting.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JobPostingWhereInput] = None,
        cursor: Optional[types.JobPostingWhereUniqueInput] = None,
        include: Optional[types.JobPostingInclude] = None,
        order: Optional[Union[types.JobPostingOrderByInput, List[types.JobPostingOrderByInput]]] = None,
        distinct: Optional[List[types.JobPostingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single JobPosting record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JobPosting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobPosting model
        order
            Order the returned JobPosting records by any field
        distinct
            Filter JobPosting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JobPosting
            The first JobPosting record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JobPosting record ordered by the description field
        jobposting = await JobPosting.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JobPostingWhereInput] = None,
        cursor: Optional[types.JobPostingWhereUniqueInput] = None,
        include: Optional[types.JobPostingInclude] = None,
        order: Optional[Union[types.JobPostingOrderByInput, List[types.JobPostingOrderByInput]]] = None,
        distinct: Optional[List[types.JobPostingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single JobPosting record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JobPosting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobPosting model
        order
            Order the returned JobPosting records by any field
        distinct
            Filter JobPosting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JobPosting
            The first JobPosting record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JobPosting record ordered by the qualifications field
        jobposting = await JobPosting.prisma().find_first_or_raise(
            skip=1,
            order={
                'qualifications': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.JobPostingUpdateInput,
        where: types.JobPostingWhereUniqueInput,
        include: Optional[types.JobPostingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single JobPosting record.

        Parameters
        ----------
        data
            JobPosting record data specifying what to update
        where
            JobPosting filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned JobPosting model

        Returns
        -------
        prisma.models.JobPosting
            The updated JobPosting record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        jobposting = await JobPosting.prisma().update(
            where={
                'id': 'bfidgijfjc',
            },
            data={
                # data to update the JobPosting record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.JobPostingWhereUniqueInput,
        data: types.JobPostingUpsertInput,
        include: Optional[types.JobPostingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            JobPosting filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned JobPosting model

        Returns
        -------
        prisma.models.JobPosting
            The created or updated JobPosting record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobposting = await JobPosting.prisma().upsert(
            where={
                'id': 'ihieecagf',
            },
            data={
                'create': {
                    'id': 'ihieecagf',
                    'jobId': 'hgdhbjhhj',
                    'title': 'ecjjjfbae',
                    'description': 'bhhfibbigf',
                    'url': 'ijdbeffgg',
                    'companyId': 'jjfeafhfj',
                    'locationId': 'cbachdgfce',
                },
                'update': {
                    'jobId': 'hgdhbjhhj',
                    'title': 'ecjjjfbae',
                    'description': 'bhhfibbigf',
                    'url': 'ijdbeffgg',
                    'companyId': 'jjfeafhfj',
                    'locationId': 'cbachdgfce',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.JobPostingUpdateManyMutationInput,
        where: types.JobPostingWhereInput,
    ) -> int:
        """Update multiple JobPosting records

        Parameters
        ----------
        data
            JobPosting data to update the selected JobPosting records to
        where
            Filter to select the JobPosting records to update

        Returns
        -------
        int
            The total number of JobPosting records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all JobPosting records
        total = await JobPosting.prisma().update_many(
            data={
                'responsibilities': Json({'bghfciaafe': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobPostingWhereInput] = None,
        cursor: Optional[types.JobPostingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of JobPosting records present in the database

        Parameters
        ----------
        select
            Select the JobPosting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JobPosting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JobPostingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JobPosting.prisma().count()

        # results: prisma.types.JobPostingCountAggregateOutput
        results = await JobPosting.prisma().count(
            select={
                '_all': True,
                'benefits': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.JobPostingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobPostingWhereInput] = None,
        cursor: Optional[types.JobPostingWhereUniqueInput] = None,
    ) -> types.JobPostingCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.JobPostingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobPostingWhereInput] = None,
        cursor: Optional[types.JobPostingWhereUniqueInput] = None,
    ) -> Union[int, types.JobPostingCountAggregateOutput]:
        """Count the number of JobPosting records present in the database

        Parameters
        ----------
        select
            Select the JobPosting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JobPosting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JobPostingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JobPosting.prisma().count()

        # results: prisma.types.JobPostingCountAggregateOutput
        results = await JobPosting.prisma().count(
            select={
                '_all': True,
                'postedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.JobPostingCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.JobPostingWhereInput] = None
    ) -> int:
        """Delete multiple JobPosting records.

        Parameters
        ----------
        where
            Optional JobPosting filter to find the records to be deleted

        Returns
        -------
        int
            The total number of JobPosting records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all JobPosting records
        total = await JobPosting.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.JobPostingScalarFieldKeysT'],
        *,
        where: Optional['types.JobPostingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.JobPostingAvgAggregateInput'] = None,
        sum: Optional['types.JobPostingSumAggregateInput'] = None,
        min: Optional['types.JobPostingMinAggregateInput'] = None,
        max: Optional['types.JobPostingMaxAggregateInput'] = None,
        having: Optional['types.JobPostingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.JobPostingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.JobPostingScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.JobPostingScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.JobPostingGroupByOutput']:
        """Group JobPosting records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar JobPosting fields to group records by
        where
            JobPosting filter to select records
        take
            Limit the maximum number of JobPosting records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.JobPostingGroupByOutput]
            A list of dictionaries representing the JobPosting record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group JobPosting records by scrapedAt values
        # and count how many records are in each group
        results = await JobPosting.prisma().group_by(
            ['scrapedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SkillActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Skill]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Skill.prisma().query_raw(
            'SELECT * FROM Skill WHERE id = $1',
            'bgchfhgceh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Skill
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Skill.prisma().query_first(
            'SELECT * FROM Skill WHERE label = $1',
            'cafeiaccbc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SkillCreateInput,
        include: Optional[types.SkillInclude] = None
    ) -> _PrismaModelT:
        """Create a new Skill record.

        Parameters
        ----------
        data
            Skill record data
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The created Skill record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Skill record from just the required fields
        skill = await Skill.prisma().create(
            data={
                # data to create a Skill record
                'label': 'gaddfhfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SkillCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Skill records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Skill record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Skill.prisma().create_many(
            data=[
                {
                    # data to create a Skill record
                    'label': 'gieegcbeg',
                },
                {
                    # data to create a Skill record
                    'label': 'bgcffadich',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SkillWhereUniqueInput,
        include: Optional[types.SkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Skill record.

        Parameters
        ----------
        where
            Skill filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The deleted Skill record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skill = await Skill.prisma().delete(
            where={
                'id': 'fcbichhci',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SkillWhereUniqueInput,
        include: Optional[types.SkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Skill record.

        Parameters
        ----------
        where
            Skill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The found Skill record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skill = await Skill.prisma().find_unique(
            where={
                'id': 'bcggadccgf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SkillWhereUniqueInput,
        include: Optional[types.SkillInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Skill record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Skill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The found Skill record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skill = await Skill.prisma().find_unique_or_raise(
            where={
                'id': 'jdcfdcgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
        include: Optional[types.SkillInclude] = None,
        order: Optional[Union[types.SkillOrderByInput, List[types.SkillOrderByInput]]] = None,
        distinct: Optional[List[types.SkillScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Skill records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Skill records returned
        skip
            Ignore the first N results
        where
            Skill filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Skill model
        order
            Order the returned Skill records by any field
        distinct
            Filter Skill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Skill]
            The list of all Skill records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Skill records
        skills = await Skill.prisma().find_many(take=10)

        # find the first 5 Skill records ordered by the altLabels field
        skills = await Skill.prisma().find_many(
            take=5,
            order={
                'altLabels': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
        include: Optional[types.SkillInclude] = None,
        order: Optional[Union[types.SkillOrderByInput, List[types.SkillOrderByInput]]] = None,
        distinct: Optional[List[types.SkillScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Skill record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Skill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Skill model
        order
            Order the returned Skill records by any field
        distinct
            Filter Skill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Skill
            The first Skill record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Skill record ordered by the skill_type field
        skill = await Skill.prisma().find_first(
            skip=1,
            order={
                'skill_type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
        include: Optional[types.SkillInclude] = None,
        order: Optional[Union[types.SkillOrderByInput, List[types.SkillOrderByInput]]] = None,
        distinct: Optional[List[types.SkillScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Skill record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Skill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Skill model
        order
            Order the returned Skill records by any field
        distinct
            Filter Skill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Skill
            The first Skill record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Skill record ordered by the status field
        skill = await Skill.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SkillUpdateInput,
        where: types.SkillWhereUniqueInput,
        include: Optional[types.SkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Skill record.

        Parameters
        ----------
        data
            Skill record data specifying what to update
        where
            Skill filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The updated Skill record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        skill = await Skill.prisma().update(
            where={
                'id': 'cafdaehjid',
            },
            data={
                # data to update the Skill record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SkillWhereUniqueInput,
        data: types.SkillUpsertInput,
        include: Optional[types.SkillInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Skill filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The created or updated Skill record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skill = await Skill.prisma().upsert(
            where={
                'id': 'gifdddbia',
            },
            data={
                'create': {
                    'id': 'gifdddbia',
                    'label': 'bgcffadich',
                },
                'update': {
                    'label': 'bgcffadich',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SkillUpdateManyMutationInput,
        where: types.SkillWhereInput,
    ) -> int:
        """Update multiple Skill records

        Parameters
        ----------
        data
            Skill data to update the selected Skill records to
        where
            Filter to select the Skill records to update

        Returns
        -------
        int
            The total number of Skill records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Skill records
        total = await Skill.prisma().update_many(
            data={
                'modified_at': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Skill records present in the database

        Parameters
        ----------
        select
            Select the Skill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Skill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Skill.prisma().count()

        # results: prisma.types.SkillCountAggregateOutput
        results = await Skill.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SkillCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
    ) -> types.SkillCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SkillCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
    ) -> Union[int, types.SkillCountAggregateOutput]:
        """Count the number of Skill records present in the database

        Parameters
        ----------
        select
            Select the Skill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Skill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Skill.prisma().count()

        # results: prisma.types.SkillCountAggregateOutput
        results = await Skill.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SkillCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SkillWhereInput] = None
    ) -> int:
        """Delete multiple Skill records.

        Parameters
        ----------
        where
            Optional Skill filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Skill records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Skill records
        total = await Skill.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SkillScalarFieldKeysT'],
        *,
        where: Optional['types.SkillWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SkillAvgAggregateInput'] = None,
        sum: Optional['types.SkillSumAggregateInput'] = None,
        min: Optional['types.SkillMinAggregateInput'] = None,
        max: Optional['types.SkillMaxAggregateInput'] = None,
        having: Optional['types.SkillScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SkillCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SkillScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.SkillScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.SkillGroupByOutput']:
        """Group Skill records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Skill fields to group records by
        where
            Skill filter to select records
        take
            Limit the maximum number of Skill records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SkillGroupByOutput]
            A list of dictionaries representing the Skill record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Skill records by label values
        # and count how many records are in each group
        results = await Skill.prisma().group_by(
            ['label'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class JobSkillActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.JobSkill]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await JobSkill.prisma().query_raw(
            'SELECT * FROM JobSkill WHERE jobId = $1',
            'bchehecef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.JobSkill
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await JobSkill.prisma().query_first(
            'SELECT * FROM JobSkill WHERE skillId = $1',
            'jeijcbhfe',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.JobSkillCreateInput,
        include: Optional[types.JobSkillInclude] = None
    ) -> _PrismaModelT:
        """Create a new JobSkill record.

        Parameters
        ----------
        data
            JobSkill record data
        include
            Specifies which relations should be loaded on the returned JobSkill model

        Returns
        -------
        prisma.models.JobSkill
            The created JobSkill record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a JobSkill record from just the required fields
        jobskill = await JobSkill.prisma().create(
            data={
                # data to create a JobSkill record
                'jobId': 'bjgejjabff',
                'skillId': 'bcciijbibg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.JobSkillCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple JobSkill records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of JobSkill record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await JobSkill.prisma().create_many(
            data=[
                {
                    # data to create a JobSkill record
                    'jobId': 'cffcachfd',
                    'skillId': 'bccdfhdigc',
                },
                {
                    # data to create a JobSkill record
                    'jobId': 'febcgjbfj',
                    'skillId': 'bageiegghg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.JobSkillWhereUniqueInput,
        include: Optional[types.JobSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single JobSkill record.

        Parameters
        ----------
        where
            JobSkill filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned JobSkill model

        Returns
        -------
        prisma.models.JobSkill
            The deleted JobSkill record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobskill = await JobSkill.prisma().delete(
            where={
                # JobSkill where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.JobSkillWhereUniqueInput,
        include: Optional[types.JobSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique JobSkill record.

        Parameters
        ----------
        where
            JobSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JobSkill model

        Returns
        -------
        prisma.models.JobSkill
            The found JobSkill record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobskill = await JobSkill.prisma().find_unique(
            where={
                # JobSkill where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.JobSkillWhereUniqueInput,
        include: Optional[types.JobSkillInclude] = None
    ) -> _PrismaModelT:
        """Find a unique JobSkill record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            JobSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned JobSkill model

        Returns
        -------
        prisma.models.JobSkill
            The found JobSkill record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobskill = await JobSkill.prisma().find_unique_or_raise(
            where={
                # JobSkill where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobSkillWhereInput] = None,
        cursor: Optional[types.JobSkillWhereUniqueInput] = None,
        include: Optional[types.JobSkillInclude] = None,
        order: Optional[Union[types.JobSkillOrderByInput, List[types.JobSkillOrderByInput]]] = None,
        distinct: Optional[List[types.JobSkillScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple JobSkill records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of JobSkill records returned
        skip
            Ignore the first N results
        where
            JobSkill filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobSkill model
        order
            Order the returned JobSkill records by any field
        distinct
            Filter JobSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.JobSkill]
            The list of all JobSkill records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 JobSkill records
        jobskills = await JobSkill.prisma().find_many(take=10)

        # find the first 5 JobSkill records ordered by the jobId field
        jobskills = await JobSkill.prisma().find_many(
            take=5,
            order={
                'jobId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JobSkillWhereInput] = None,
        cursor: Optional[types.JobSkillWhereUniqueInput] = None,
        include: Optional[types.JobSkillInclude] = None,
        order: Optional[Union[types.JobSkillOrderByInput, List[types.JobSkillOrderByInput]]] = None,
        distinct: Optional[List[types.JobSkillScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single JobSkill record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JobSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobSkill model
        order
            Order the returned JobSkill records by any field
        distinct
            Filter JobSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JobSkill
            The first JobSkill record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JobSkill record ordered by the skillId field
        jobskill = await JobSkill.prisma().find_first(
            skip=1,
            order={
                'skillId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.JobSkillWhereInput] = None,
        cursor: Optional[types.JobSkillWhereUniqueInput] = None,
        include: Optional[types.JobSkillInclude] = None,
        order: Optional[Union[types.JobSkillOrderByInput, List[types.JobSkillOrderByInput]]] = None,
        distinct: Optional[List[types.JobSkillScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single JobSkill record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            JobSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned JobSkill model
        order
            Order the returned JobSkill records by any field
        distinct
            Filter JobSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.JobSkill
            The first JobSkill record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second JobSkill record ordered by the jobId field
        jobskill = await JobSkill.prisma().find_first_or_raise(
            skip=1,
            order={
                'jobId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.JobSkillUpdateInput,
        where: types.JobSkillWhereUniqueInput,
        include: Optional[types.JobSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single JobSkill record.

        Parameters
        ----------
        data
            JobSkill record data specifying what to update
        where
            JobSkill filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned JobSkill model

        Returns
        -------
        prisma.models.JobSkill
            The updated JobSkill record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        jobskill = await JobSkill.prisma().update(
            where={
                # JobSkill where unique filter

            },
            data={
                # data to update the JobSkill record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.JobSkillWhereUniqueInput,
        data: types.JobSkillUpsertInput,
        include: Optional[types.JobSkillInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            JobSkill filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned JobSkill model

        Returns
        -------
        prisma.models.JobSkill
            The created or updated JobSkill record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        jobskill = await JobSkill.prisma().upsert(
            where={
                # JobSkill where unique filter
            },
            data={
                'create': {
                    # JobSkill data to be set if the record does not exist
                },
                'update': {
                    # JobSkill data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.JobSkillUpdateManyMutationInput,
        where: types.JobSkillWhereInput,
    ) -> int:
        """Update multiple JobSkill records

        Parameters
        ----------
        data
            JobSkill data to update the selected JobSkill records to
        where
            Filter to select the JobSkill records to update

        Returns
        -------
        int
            The total number of JobSkill records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all JobSkill records
        total = await JobSkill.prisma().update_many(
            data={
                'skillId': 'faidicegb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobSkillWhereInput] = None,
        cursor: Optional[types.JobSkillWhereUniqueInput] = None,
    ) -> int:
        """Count the number of JobSkill records present in the database

        Parameters
        ----------
        select
            Select the JobSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JobSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JobSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JobSkill.prisma().count()

        # results: prisma.types.JobSkillCountAggregateOutput
        results = await JobSkill.prisma().count(
            select={
                '_all': True,
                'jobId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.JobSkillCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobSkillWhereInput] = None,
        cursor: Optional[types.JobSkillWhereUniqueInput] = None,
    ) -> types.JobSkillCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.JobSkillCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.JobSkillWhereInput] = None,
        cursor: Optional[types.JobSkillWhereUniqueInput] = None,
    ) -> Union[int, types.JobSkillCountAggregateOutput]:
        """Count the number of JobSkill records present in the database

        Parameters
        ----------
        select
            Select the JobSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            JobSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.JobSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await JobSkill.prisma().count()

        # results: prisma.types.JobSkillCountAggregateOutput
        results = await JobSkill.prisma().count(
            select={
                '_all': True,
                'skillId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.JobSkillCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.JobSkillWhereInput] = None
    ) -> int:
        """Delete multiple JobSkill records.

        Parameters
        ----------
        where
            Optional JobSkill filter to find the records to be deleted

        Returns
        -------
        int
            The total number of JobSkill records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all JobSkill records
        total = await JobSkill.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.JobSkillScalarFieldKeysT'],
        *,
        where: Optional['types.JobSkillWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.JobSkillAvgAggregateInput'] = None,
        sum: Optional['types.JobSkillSumAggregateInput'] = None,
        min: Optional['types.JobSkillMinAggregateInput'] = None,
        max: Optional['types.JobSkillMaxAggregateInput'] = None,
        having: Optional['types.JobSkillScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.JobSkillCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.JobSkillScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.JobSkillScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.JobSkillGroupByOutput']:
        """Group JobSkill records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar JobSkill fields to group records by
        where
            JobSkill filter to select records
        take
            Limit the maximum number of JobSkill records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.JobSkillGroupByOutput]
            A list of dictionaries representing the JobSkill record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group JobSkill records by jobId values
        # and count how many records are in each group
        results = await JobSkill.prisma().group_by(
            ['jobId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OccupationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Occupation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Occupation.prisma().query_raw(
            'SELECT * FROM Occupation WHERE id = $1',
            'bacecgfhbe',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Occupation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Occupation.prisma().query_first(
            'SELECT * FROM Occupation WHERE title = $1',
            'ihcahiead',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OccupationCreateInput,
        include: Optional[types.OccupationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Occupation record.

        Parameters
        ----------
        data
            Occupation record data
        include
            Specifies which relations should be loaded on the returned Occupation model

        Returns
        -------
        prisma.models.Occupation
            The created Occupation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Occupation record from just the required fields
        occupation = await Occupation.prisma().create(
            data={
                # data to create a Occupation record
                'title': 'biheheiajg',
                'source': 'jbgijghgb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OccupationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Occupation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Occupation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Occupation.prisma().create_many(
            data=[
                {
                    # data to create a Occupation record
                    'title': 'hgjcghfbi',
                    'source': 'icadbcehj',
                },
                {
                    # data to create a Occupation record
                    'title': 'jchciaee',
                    'source': 'deeificjd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OccupationWhereUniqueInput,
        include: Optional[types.OccupationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Occupation record.

        Parameters
        ----------
        where
            Occupation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Occupation model

        Returns
        -------
        prisma.models.Occupation
            The deleted Occupation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        occupation = await Occupation.prisma().delete(
            where={
                'id': 'bbcbhebbda',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OccupationWhereUniqueInput,
        include: Optional[types.OccupationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Occupation record.

        Parameters
        ----------
        where
            Occupation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Occupation model

        Returns
        -------
        prisma.models.Occupation
            The found Occupation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        occupation = await Occupation.prisma().find_unique(
            where={
                'id': 'bejfijgcfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OccupationWhereUniqueInput,
        include: Optional[types.OccupationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Occupation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Occupation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Occupation model

        Returns
        -------
        prisma.models.Occupation
            The found Occupation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        occupation = await Occupation.prisma().find_unique_or_raise(
            where={
                'id': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OccupationWhereInput] = None,
        cursor: Optional[types.OccupationWhereUniqueInput] = None,
        include: Optional[types.OccupationInclude] = None,
        order: Optional[Union[types.OccupationOrderByInput, List[types.OccupationOrderByInput]]] = None,
        distinct: Optional[List[types.OccupationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Occupation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Occupation records returned
        skip
            Ignore the first N results
        where
            Occupation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Occupation model
        order
            Order the returned Occupation records by any field
        distinct
            Filter Occupation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Occupation]
            The list of all Occupation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Occupation records
        occupations = await Occupation.prisma().find_many(take=10)

        # find the first 5 Occupation records ordered by the description field
        occupations = await Occupation.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OccupationWhereInput] = None,
        cursor: Optional[types.OccupationWhereUniqueInput] = None,
        include: Optional[types.OccupationInclude] = None,
        order: Optional[Union[types.OccupationOrderByInput, List[types.OccupationOrderByInput]]] = None,
        distinct: Optional[List[types.OccupationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Occupation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Occupation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Occupation model
        order
            Order the returned Occupation records by any field
        distinct
            Filter Occupation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Occupation
            The first Occupation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Occupation record ordered by the source field
        occupation = await Occupation.prisma().find_first(
            skip=1,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OccupationWhereInput] = None,
        cursor: Optional[types.OccupationWhereUniqueInput] = None,
        include: Optional[types.OccupationInclude] = None,
        order: Optional[Union[types.OccupationOrderByInput, List[types.OccupationOrderByInput]]] = None,
        distinct: Optional[List[types.OccupationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Occupation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Occupation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Occupation model
        order
            Order the returned Occupation records by any field
        distinct
            Filter Occupation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Occupation
            The first Occupation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Occupation record ordered by the id field
        occupation = await Occupation.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OccupationUpdateInput,
        where: types.OccupationWhereUniqueInput,
        include: Optional[types.OccupationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Occupation record.

        Parameters
        ----------
        data
            Occupation record data specifying what to update
        where
            Occupation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Occupation model

        Returns
        -------
        prisma.models.Occupation
            The updated Occupation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        occupation = await Occupation.prisma().update(
            where={
                'id': 'igaibbfgj',
            },
            data={
                # data to update the Occupation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OccupationWhereUniqueInput,
        data: types.OccupationUpsertInput,
        include: Optional[types.OccupationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Occupation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Occupation model

        Returns
        -------
        prisma.models.Occupation
            The created or updated Occupation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        occupation = await Occupation.prisma().upsert(
            where={
                'id': 'bggajdcbbi',
            },
            data={
                'create': {
                    'id': 'bggajdcbbi',
                    'title': 'jchciaee',
                    'source': 'deeificjd',
                },
                'update': {
                    'title': 'jchciaee',
                    'source': 'deeificjd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OccupationUpdateManyMutationInput,
        where: types.OccupationWhereInput,
    ) -> int:
        """Update multiple Occupation records

        Parameters
        ----------
        data
            Occupation data to update the selected Occupation records to
        where
            Filter to select the Occupation records to update

        Returns
        -------
        int
            The total number of Occupation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Occupation records
        total = await Occupation.prisma().update_many(
            data={
                'title': 'fcfhgbjed'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OccupationWhereInput] = None,
        cursor: Optional[types.OccupationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Occupation records present in the database

        Parameters
        ----------
        select
            Select the Occupation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Occupation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OccupationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Occupation.prisma().count()

        # results: prisma.types.OccupationCountAggregateOutput
        results = await Occupation.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OccupationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OccupationWhereInput] = None,
        cursor: Optional[types.OccupationWhereUniqueInput] = None,
    ) -> types.OccupationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OccupationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OccupationWhereInput] = None,
        cursor: Optional[types.OccupationWhereUniqueInput] = None,
    ) -> Union[int, types.OccupationCountAggregateOutput]:
        """Count the number of Occupation records present in the database

        Parameters
        ----------
        select
            Select the Occupation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Occupation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OccupationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Occupation.prisma().count()

        # results: prisma.types.OccupationCountAggregateOutput
        results = await Occupation.prisma().count(
            select={
                '_all': True,
                'source': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OccupationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OccupationWhereInput] = None
    ) -> int:
        """Delete multiple Occupation records.

        Parameters
        ----------
        where
            Optional Occupation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Occupation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Occupation records
        total = await Occupation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OccupationScalarFieldKeysT'],
        *,
        where: Optional['types.OccupationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OccupationAvgAggregateInput'] = None,
        sum: Optional['types.OccupationSumAggregateInput'] = None,
        min: Optional['types.OccupationMinAggregateInput'] = None,
        max: Optional['types.OccupationMaxAggregateInput'] = None,
        having: Optional['types.OccupationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OccupationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OccupationScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.OccupationScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.OccupationGroupByOutput']:
        """Group Occupation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Occupation fields to group records by
        where
            Occupation filter to select records
        take
            Limit the maximum number of Occupation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OccupationGroupByOutput]
            A list of dictionaries representing the Occupation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Occupation records by id values
        # and count how many records are in each group
        results = await Occupation.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OccupationSkillActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.OccupationSkill]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await OccupationSkill.prisma().query_raw(
            'SELECT * FROM OccupationSkill WHERE occupationId = $1',
            'hdgcajhjg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.OccupationSkill
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await OccupationSkill.prisma().query_first(
            'SELECT * FROM OccupationSkill WHERE skillId = $1',
            'ejdjahicb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OccupationSkillCreateInput,
        include: Optional[types.OccupationSkillInclude] = None
    ) -> _PrismaModelT:
        """Create a new OccupationSkill record.

        Parameters
        ----------
        data
            OccupationSkill record data
        include
            Specifies which relations should be loaded on the returned OccupationSkill model

        Returns
        -------
        prisma.models.OccupationSkill
            The created OccupationSkill record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a OccupationSkill record from just the required fields
        occupationskill = await OccupationSkill.prisma().create(
            data={
                # data to create a OccupationSkill record
                'occupationId': 'gdjgigfgc',
                'skillId': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OccupationSkillCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple OccupationSkill records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of OccupationSkill record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await OccupationSkill.prisma().create_many(
            data=[
                {
                    # data to create a OccupationSkill record
                    'occupationId': 'bjafcgbffc',
                    'skillId': 'hihegjif',
                },
                {
                    # data to create a OccupationSkill record
                    'occupationId': 'bdjidcidac',
                    'skillId': 'ifgaaagff',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OccupationSkillWhereUniqueInput,
        include: Optional[types.OccupationSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single OccupationSkill record.

        Parameters
        ----------
        where
            OccupationSkill filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned OccupationSkill model

        Returns
        -------
        prisma.models.OccupationSkill
            The deleted OccupationSkill record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        occupationskill = await OccupationSkill.prisma().delete(
            where={
                # OccupationSkill where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OccupationSkillWhereUniqueInput,
        include: Optional[types.OccupationSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique OccupationSkill record.

        Parameters
        ----------
        where
            OccupationSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OccupationSkill model

        Returns
        -------
        prisma.models.OccupationSkill
            The found OccupationSkill record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        occupationskill = await OccupationSkill.prisma().find_unique(
            where={
                # OccupationSkill where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OccupationSkillWhereUniqueInput,
        include: Optional[types.OccupationSkillInclude] = None
    ) -> _PrismaModelT:
        """Find a unique OccupationSkill record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            OccupationSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OccupationSkill model

        Returns
        -------
        prisma.models.OccupationSkill
            The found OccupationSkill record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        occupationskill = await OccupationSkill.prisma().find_unique_or_raise(
            where={
                # OccupationSkill where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OccupationSkillWhereInput] = None,
        cursor: Optional[types.OccupationSkillWhereUniqueInput] = None,
        include: Optional[types.OccupationSkillInclude] = None,
        order: Optional[Union[types.OccupationSkillOrderByInput, List[types.OccupationSkillOrderByInput]]] = None,
        distinct: Optional[List[types.OccupationSkillScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple OccupationSkill records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of OccupationSkill records returned
        skip
            Ignore the first N results
        where
            OccupationSkill filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OccupationSkill model
        order
            Order the returned OccupationSkill records by any field
        distinct
            Filter OccupationSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.OccupationSkill]
            The list of all OccupationSkill records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 OccupationSkill records
        occupationskills = await OccupationSkill.prisma().find_many(take=10)

        # find the first 5 OccupationSkill records ordered by the relationType field
        occupationskills = await OccupationSkill.prisma().find_many(
            take=5,
            order={
                'relationType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OccupationSkillWhereInput] = None,
        cursor: Optional[types.OccupationSkillWhereUniqueInput] = None,
        include: Optional[types.OccupationSkillInclude] = None,
        order: Optional[Union[types.OccupationSkillOrderByInput, List[types.OccupationSkillOrderByInput]]] = None,
        distinct: Optional[List[types.OccupationSkillScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single OccupationSkill record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OccupationSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OccupationSkill model
        order
            Order the returned OccupationSkill records by any field
        distinct
            Filter OccupationSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OccupationSkill
            The first OccupationSkill record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OccupationSkill record ordered by the skillType field
        occupationskill = await OccupationSkill.prisma().find_first(
            skip=1,
            order={
                'skillType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OccupationSkillWhereInput] = None,
        cursor: Optional[types.OccupationSkillWhereUniqueInput] = None,
        include: Optional[types.OccupationSkillInclude] = None,
        order: Optional[Union[types.OccupationSkillOrderByInput, List[types.OccupationSkillOrderByInput]]] = None,
        distinct: Optional[List[types.OccupationSkillScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single OccupationSkill record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OccupationSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OccupationSkill model
        order
            Order the returned OccupationSkill records by any field
        distinct
            Filter OccupationSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OccupationSkill
            The first OccupationSkill record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OccupationSkill record ordered by the occupationId field
        occupationskill = await OccupationSkill.prisma().find_first_or_raise(
            skip=1,
            order={
                'occupationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OccupationSkillUpdateInput,
        where: types.OccupationSkillWhereUniqueInput,
        include: Optional[types.OccupationSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single OccupationSkill record.

        Parameters
        ----------
        data
            OccupationSkill record data specifying what to update
        where
            OccupationSkill filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned OccupationSkill model

        Returns
        -------
        prisma.models.OccupationSkill
            The updated OccupationSkill record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        occupationskill = await OccupationSkill.prisma().update(
            where={
                # OccupationSkill where unique filter

            },
            data={
                # data to update the OccupationSkill record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OccupationSkillWhereUniqueInput,
        data: types.OccupationSkillUpsertInput,
        include: Optional[types.OccupationSkillInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            OccupationSkill filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned OccupationSkill model

        Returns
        -------
        prisma.models.OccupationSkill
            The created or updated OccupationSkill record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        occupationskill = await OccupationSkill.prisma().upsert(
            where={
                # OccupationSkill where unique filter
            },
            data={
                'create': {
                    # OccupationSkill data to be set if the record does not exist
                },
                'update': {
                    # OccupationSkill data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OccupationSkillUpdateManyMutationInput,
        where: types.OccupationSkillWhereInput,
    ) -> int:
        """Update multiple OccupationSkill records

        Parameters
        ----------
        data
            OccupationSkill data to update the selected OccupationSkill records to
        where
            Filter to select the OccupationSkill records to update

        Returns
        -------
        int
            The total number of OccupationSkill records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all OccupationSkill records
        total = await OccupationSkill.prisma().update_many(
            data={
                'skillId': 'befcddgjce'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OccupationSkillWhereInput] = None,
        cursor: Optional[types.OccupationSkillWhereUniqueInput] = None,
    ) -> int:
        """Count the number of OccupationSkill records present in the database

        Parameters
        ----------
        select
            Select the OccupationSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OccupationSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OccupationSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OccupationSkill.prisma().count()

        # results: prisma.types.OccupationSkillCountAggregateOutput
        results = await OccupationSkill.prisma().count(
            select={
                '_all': True,
                'relationType': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OccupationSkillCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OccupationSkillWhereInput] = None,
        cursor: Optional[types.OccupationSkillWhereUniqueInput] = None,
    ) -> types.OccupationSkillCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OccupationSkillCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OccupationSkillWhereInput] = None,
        cursor: Optional[types.OccupationSkillWhereUniqueInput] = None,
    ) -> Union[int, types.OccupationSkillCountAggregateOutput]:
        """Count the number of OccupationSkill records present in the database

        Parameters
        ----------
        select
            Select the OccupationSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OccupationSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OccupationSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OccupationSkill.prisma().count()

        # results: prisma.types.OccupationSkillCountAggregateOutput
        results = await OccupationSkill.prisma().count(
            select={
                '_all': True,
                'skillType': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OccupationSkillCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OccupationSkillWhereInput] = None
    ) -> int:
        """Delete multiple OccupationSkill records.

        Parameters
        ----------
        where
            Optional OccupationSkill filter to find the records to be deleted

        Returns
        -------
        int
            The total number of OccupationSkill records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all OccupationSkill records
        total = await OccupationSkill.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OccupationSkillScalarFieldKeysT'],
        *,
        where: Optional['types.OccupationSkillWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OccupationSkillAvgAggregateInput'] = None,
        sum: Optional['types.OccupationSkillSumAggregateInput'] = None,
        min: Optional['types.OccupationSkillMinAggregateInput'] = None,
        max: Optional['types.OccupationSkillMaxAggregateInput'] = None,
        having: Optional['types.OccupationSkillScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OccupationSkillCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OccupationSkillScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.OccupationSkillScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.OccupationSkillGroupByOutput']:
        """Group OccupationSkill records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar OccupationSkill fields to group records by
        where
            OccupationSkill filter to select records
        take
            Limit the maximum number of OccupationSkill records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OccupationSkillGroupByOutput]
            A list of dictionaries representing the OccupationSkill record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group OccupationSkill records by occupationId values
        # and count how many records are in each group
        results = await OccupationSkill.prisma().group_by(
            ['occupationId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ResumeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Resume]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Resume.prisma().query_raw(
            'SELECT * FROM Resume WHERE id = $1',
            'bfhdbjjgfd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Resume
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Resume.prisma().query_first(
            'SELECT * FROM Resume WHERE name = $1',
            'cabdjadaji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ResumeCreateInput,
        include: Optional[types.ResumeInclude] = None
    ) -> _PrismaModelT:
        """Create a new Resume record.

        Parameters
        ----------
        data
            Resume record data
        include
            Specifies which relations should be loaded on the returned Resume model

        Returns
        -------
        prisma.models.Resume
            The created Resume record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Resume record from just the required fields
        resume = await Resume.prisma().create(
            data={
                # data to create a Resume record
                'rawText': 'faajgfadf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ResumeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Resume records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Resume record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Resume.prisma().create_many(
            data=[
                {
                    # data to create a Resume record
                    'rawText': 'biaagcedjc',
                },
                {
                    # data to create a Resume record
                    'rawText': 'cahhaghecf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ResumeWhereUniqueInput,
        include: Optional[types.ResumeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Resume record.

        Parameters
        ----------
        where
            Resume filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Resume model

        Returns
        -------
        prisma.models.Resume
            The deleted Resume record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        resume = await Resume.prisma().delete(
            where={
                'id': 'bghcbbcidi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ResumeWhereUniqueInput,
        include: Optional[types.ResumeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Resume record.

        Parameters
        ----------
        where
            Resume filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Resume model

        Returns
        -------
        prisma.models.Resume
            The found Resume record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        resume = await Resume.prisma().find_unique(
            where={
                'id': 'jcgghhgdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ResumeWhereUniqueInput,
        include: Optional[types.ResumeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Resume record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Resume filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Resume model

        Returns
        -------
        prisma.models.Resume
            The found Resume record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        resume = await Resume.prisma().find_unique_or_raise(
            where={
                'id': 'beehgcebbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ResumeWhereInput] = None,
        cursor: Optional[types.ResumeWhereUniqueInput] = None,
        include: Optional[types.ResumeInclude] = None,
        order: Optional[Union[types.ResumeOrderByInput, List[types.ResumeOrderByInput]]] = None,
        distinct: Optional[List[types.ResumeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Resume records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Resume records returned
        skip
            Ignore the first N results
        where
            Resume filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Resume model
        order
            Order the returned Resume records by any field
        distinct
            Filter Resume records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Resume]
            The list of all Resume records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Resume records
        resumes = await Resume.prisma().find_many(take=10)

        # find the first 5 Resume records ordered by the email field
        resumes = await Resume.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ResumeWhereInput] = None,
        cursor: Optional[types.ResumeWhereUniqueInput] = None,
        include: Optional[types.ResumeInclude] = None,
        order: Optional[Union[types.ResumeOrderByInput, List[types.ResumeOrderByInput]]] = None,
        distinct: Optional[List[types.ResumeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Resume record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Resume filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Resume model
        order
            Order the returned Resume records by any field
        distinct
            Filter Resume records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Resume
            The first Resume record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Resume record ordered by the phone field
        resume = await Resume.prisma().find_first(
            skip=1,
            order={
                'phone': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ResumeWhereInput] = None,
        cursor: Optional[types.ResumeWhereUniqueInput] = None,
        include: Optional[types.ResumeInclude] = None,
        order: Optional[Union[types.ResumeOrderByInput, List[types.ResumeOrderByInput]]] = None,
        distinct: Optional[List[types.ResumeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Resume record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Resume filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Resume model
        order
            Order the returned Resume records by any field
        distinct
            Filter Resume records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Resume
            The first Resume record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Resume record ordered by the rawText field
        resume = await Resume.prisma().find_first_or_raise(
            skip=1,
            order={
                'rawText': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ResumeUpdateInput,
        where: types.ResumeWhereUniqueInput,
        include: Optional[types.ResumeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Resume record.

        Parameters
        ----------
        data
            Resume record data specifying what to update
        where
            Resume filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Resume model

        Returns
        -------
        prisma.models.Resume
            The updated Resume record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        resume = await Resume.prisma().update(
            where={
                'id': 'bhdiaidiaf',
            },
            data={
                # data to update the Resume record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ResumeWhereUniqueInput,
        data: types.ResumeUpsertInput,
        include: Optional[types.ResumeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Resume filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Resume model

        Returns
        -------
        prisma.models.Resume
            The created or updated Resume record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        resume = await Resume.prisma().upsert(
            where={
                'id': 'deajegcfi',
            },
            data={
                'create': {
                    'id': 'deajegcfi',
                    'rawText': 'cahhaghecf',
                },
                'update': {
                    'rawText': 'cahhaghecf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ResumeUpdateManyMutationInput,
        where: types.ResumeWhereInput,
    ) -> int:
        """Update multiple Resume records

        Parameters
        ----------
        data
            Resume data to update the selected Resume records to
        where
            Filter to select the Resume records to update

        Returns
        -------
        int
            The total number of Resume records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Resume records
        total = await Resume.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ResumeWhereInput] = None,
        cursor: Optional[types.ResumeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Resume records present in the database

        Parameters
        ----------
        select
            Select the Resume fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Resume filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ResumeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Resume.prisma().count()

        # results: prisma.types.ResumeCountAggregateOutput
        results = await Resume.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ResumeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ResumeWhereInput] = None,
        cursor: Optional[types.ResumeWhereUniqueInput] = None,
    ) -> types.ResumeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ResumeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ResumeWhereInput] = None,
        cursor: Optional[types.ResumeWhereUniqueInput] = None,
    ) -> Union[int, types.ResumeCountAggregateOutput]:
        """Count the number of Resume records present in the database

        Parameters
        ----------
        select
            Select the Resume fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Resume filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ResumeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Resume.prisma().count()

        # results: prisma.types.ResumeCountAggregateOutput
        results = await Resume.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ResumeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ResumeWhereInput] = None
    ) -> int:
        """Delete multiple Resume records.

        Parameters
        ----------
        where
            Optional Resume filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Resume records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Resume records
        total = await Resume.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ResumeScalarFieldKeysT'],
        *,
        where: Optional['types.ResumeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ResumeAvgAggregateInput'] = None,
        sum: Optional['types.ResumeSumAggregateInput'] = None,
        min: Optional['types.ResumeMinAggregateInput'] = None,
        max: Optional['types.ResumeMaxAggregateInput'] = None,
        having: Optional['types.ResumeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ResumeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ResumeScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ResumeScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ResumeGroupByOutput']:
        """Group Resume records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Resume fields to group records by
        where
            Resume filter to select records
        take
            Limit the maximum number of Resume records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ResumeGroupByOutput]
            A list of dictionaries representing the Resume record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Resume records by email values
        # and count how many records are in each group
        results = await Resume.prisma().group_by(
            ['email'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ResumeSkillActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ResumeSkill]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ResumeSkill.prisma().query_raw(
            'SELECT * FROM ResumeSkill WHERE id = $1',
            'gabahhhjf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ResumeSkill
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ResumeSkill.prisma().query_first(
            'SELECT * FROM ResumeSkill WHERE resumeId = $1',
            'cjagadcjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ResumeSkillCreateInput,
        include: Optional[types.ResumeSkillInclude] = None
    ) -> _PrismaModelT:
        """Create a new ResumeSkill record.

        Parameters
        ----------
        data
            ResumeSkill record data
        include
            Specifies which relations should be loaded on the returned ResumeSkill model

        Returns
        -------
        prisma.models.ResumeSkill
            The created ResumeSkill record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ResumeSkill record from just the required fields
        resumeskill = await ResumeSkill.prisma().create(
            data={
                # data to create a ResumeSkill record
                'resumeId': 'bifficggej',
                'skillName': 'bgbbaajbic',
                'source': 'eegghdhjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ResumeSkillCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ResumeSkill records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ResumeSkill record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ResumeSkill.prisma().create_many(
            data=[
                {
                    # data to create a ResumeSkill record
                    'resumeId': 'daafgidjg',
                    'skillName': 'gdcgcgagj',
                    'source': 'bhceabbgja',
                },
                {
                    # data to create a ResumeSkill record
                    'resumeId': 'ehabfhegh',
                    'skillName': 'bcajcajjbc',
                    'source': 'bfdgheeegf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ResumeSkillWhereUniqueInput,
        include: Optional[types.ResumeSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ResumeSkill record.

        Parameters
        ----------
        where
            ResumeSkill filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ResumeSkill model

        Returns
        -------
        prisma.models.ResumeSkill
            The deleted ResumeSkill record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        resumeskill = await ResumeSkill.prisma().delete(
            where={
                'id': 'ececbijji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ResumeSkillWhereUniqueInput,
        include: Optional[types.ResumeSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ResumeSkill record.

        Parameters
        ----------
        where
            ResumeSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ResumeSkill model

        Returns
        -------
        prisma.models.ResumeSkill
            The found ResumeSkill record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        resumeskill = await ResumeSkill.prisma().find_unique(
            where={
                'id': 'cbcfgdcdhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ResumeSkillWhereUniqueInput,
        include: Optional[types.ResumeSkillInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ResumeSkill record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ResumeSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ResumeSkill model

        Returns
        -------
        prisma.models.ResumeSkill
            The found ResumeSkill record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        resumeskill = await ResumeSkill.prisma().find_unique_or_raise(
            where={
                'id': 'fdgjfbhia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ResumeSkillWhereInput] = None,
        cursor: Optional[types.ResumeSkillWhereUniqueInput] = None,
        include: Optional[types.ResumeSkillInclude] = None,
        order: Optional[Union[types.ResumeSkillOrderByInput, List[types.ResumeSkillOrderByInput]]] = None,
        distinct: Optional[List[types.ResumeSkillScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ResumeSkill records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ResumeSkill records returned
        skip
            Ignore the first N results
        where
            ResumeSkill filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ResumeSkill model
        order
            Order the returned ResumeSkill records by any field
        distinct
            Filter ResumeSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ResumeSkill]
            The list of all ResumeSkill records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ResumeSkill records
        resumeskills = await ResumeSkill.prisma().find_many(take=10)

        # find the first 5 ResumeSkill records ordered by the skillName field
        resumeskills = await ResumeSkill.prisma().find_many(
            take=5,
            order={
                'skillName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ResumeSkillWhereInput] = None,
        cursor: Optional[types.ResumeSkillWhereUniqueInput] = None,
        include: Optional[types.ResumeSkillInclude] = None,
        order: Optional[Union[types.ResumeSkillOrderByInput, List[types.ResumeSkillOrderByInput]]] = None,
        distinct: Optional[List[types.ResumeSkillScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ResumeSkill record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ResumeSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ResumeSkill model
        order
            Order the returned ResumeSkill records by any field
        distinct
            Filter ResumeSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ResumeSkill
            The first ResumeSkill record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ResumeSkill record ordered by the canonicalSkillId field
        resumeskill = await ResumeSkill.prisma().find_first(
            skip=1,
            order={
                'canonicalSkillId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ResumeSkillWhereInput] = None,
        cursor: Optional[types.ResumeSkillWhereUniqueInput] = None,
        include: Optional[types.ResumeSkillInclude] = None,
        order: Optional[Union[types.ResumeSkillOrderByInput, List[types.ResumeSkillOrderByInput]]] = None,
        distinct: Optional[List[types.ResumeSkillScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ResumeSkill record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ResumeSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ResumeSkill model
        order
            Order the returned ResumeSkill records by any field
        distinct
            Filter ResumeSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ResumeSkill
            The first ResumeSkill record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ResumeSkill record ordered by the source field
        resumeskill = await ResumeSkill.prisma().find_first_or_raise(
            skip=1,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ResumeSkillUpdateInput,
        where: types.ResumeSkillWhereUniqueInput,
        include: Optional[types.ResumeSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ResumeSkill record.

        Parameters
        ----------
        data
            ResumeSkill record data specifying what to update
        where
            ResumeSkill filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ResumeSkill model

        Returns
        -------
        prisma.models.ResumeSkill
            The updated ResumeSkill record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        resumeskill = await ResumeSkill.prisma().update(
            where={
                'id': 'jcehcdchh',
            },
            data={
                # data to update the ResumeSkill record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ResumeSkillWhereUniqueInput,
        data: types.ResumeSkillUpsertInput,
        include: Optional[types.ResumeSkillInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ResumeSkill filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ResumeSkill model

        Returns
        -------
        prisma.models.ResumeSkill
            The created or updated ResumeSkill record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        resumeskill = await ResumeSkill.prisma().upsert(
            where={
                'id': 'bgcbjdhjcc',
            },
            data={
                'create': {
                    'id': 'bgcbjdhjcc',
                    'resumeId': 'ehabfhegh',
                    'skillName': 'bcajcajjbc',
                    'source': 'bfdgheeegf',
                },
                'update': {
                    'resumeId': 'ehabfhegh',
                    'skillName': 'bcajcajjbc',
                    'source': 'bfdgheeegf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ResumeSkillUpdateManyMutationInput,
        where: types.ResumeSkillWhereInput,
    ) -> int:
        """Update multiple ResumeSkill records

        Parameters
        ----------
        data
            ResumeSkill data to update the selected ResumeSkill records to
        where
            Filter to select the ResumeSkill records to update

        Returns
        -------
        int
            The total number of ResumeSkill records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ResumeSkill records
        total = await ResumeSkill.prisma().update_many(
            data={
                'id': 'bieiidcabj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ResumeSkillWhereInput] = None,
        cursor: Optional[types.ResumeSkillWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ResumeSkill records present in the database

        Parameters
        ----------
        select
            Select the ResumeSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ResumeSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ResumeSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ResumeSkill.prisma().count()

        # results: prisma.types.ResumeSkillCountAggregateOutput
        results = await ResumeSkill.prisma().count(
            select={
                '_all': True,
                'resumeId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ResumeSkillCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ResumeSkillWhereInput] = None,
        cursor: Optional[types.ResumeSkillWhereUniqueInput] = None,
    ) -> types.ResumeSkillCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ResumeSkillCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ResumeSkillWhereInput] = None,
        cursor: Optional[types.ResumeSkillWhereUniqueInput] = None,
    ) -> Union[int, types.ResumeSkillCountAggregateOutput]:
        """Count the number of ResumeSkill records present in the database

        Parameters
        ----------
        select
            Select the ResumeSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ResumeSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ResumeSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ResumeSkill.prisma().count()

        # results: prisma.types.ResumeSkillCountAggregateOutput
        results = await ResumeSkill.prisma().count(
            select={
                '_all': True,
                'skillName': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ResumeSkillCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ResumeSkillWhereInput] = None
    ) -> int:
        """Delete multiple ResumeSkill records.

        Parameters
        ----------
        where
            Optional ResumeSkill filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ResumeSkill records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ResumeSkill records
        total = await ResumeSkill.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ResumeSkillScalarFieldKeysT'],
        *,
        where: Optional['types.ResumeSkillWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ResumeSkillAvgAggregateInput'] = None,
        sum: Optional['types.ResumeSkillSumAggregateInput'] = None,
        min: Optional['types.ResumeSkillMinAggregateInput'] = None,
        max: Optional['types.ResumeSkillMaxAggregateInput'] = None,
        having: Optional['types.ResumeSkillScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ResumeSkillCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ResumeSkillScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ResumeSkillScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ResumeSkillGroupByOutput']:
        """Group ResumeSkill records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ResumeSkill fields to group records by
        where
            ResumeSkill filter to select records
        take
            Limit the maximum number of ResumeSkill records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ResumeSkillGroupByOutput]
            A list of dictionaries representing the ResumeSkill record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ResumeSkill records by canonicalSkillId values
        # and count how many records are in each group
        results = await ResumeSkill.prisma().group_by(
            ['canonicalSkillId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models